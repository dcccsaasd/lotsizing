<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>clspBenders module &#8212; MIMPLS Benders 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="dw2 module" href="dw2.html" />
    <link rel="prev" title="Welcome to MIMPLS Benders documentation!" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dw2.html" title="dw2 module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to MIMPLS Benders documentation!"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MIMPLS Benders 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-clspBenders">
<span id="clspbenders-module"></span><h1>clspBenders module<a class="headerlink" href="#module-clspBenders" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Filename:</th><td class="field-body">clspBenders.py</td>
</tr>
<tr class="field-even field"><th class="field-name">Author:</th><td class="field-body">marco caserta</td>
</tr>
<tr class="field-odd field"><th class="field-name">Date:</th><td class="field-body">09.03.2017</td>
</tr>
<tr class="field-even field"><th class="field-name">Last Update:</th><td class="field-body">01.06.17</td>
</tr>
</tbody>
</table>
<p>Copyright (C) 2017 by Marco Caserta  (marco dot caserta at ie dot edu)</p>
<p>(This document was generated on 01.06.17 at 12:54.)</p>
<hr class="docutils" />
<blockquote>
<div><p>This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.</p>
<p>You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place - Suite 330, Boston, MA  02111-1307, USA.</p>
</div></blockquote>
<hr class="docutils" />
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><strong>NOTE</strong>: A completely modified version of this code is presented below.</p>
<p>This code implements a simple benders decomposition scheme for the
multi-item multi-period capacitated lot sizing problem. Benders cuts are added
via LazyConstraintCallback(). The case of an infeasibility cut is not
considered, since the subproblem is always feasible (due to the possibility
to choose an arbitrarily large value for the initial inventory level.) This
should be improved adding a cut based on extreme rays.</p>
<p>The following is a formulation for the MIMPLS:</p>
<div class="math">
<p><img src="_images/math/315f71c3becfb35f83611d5c12cbfd88bed99de5.png" alt="\begin{eqnarray}
   \max     &amp; &amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T (f_{jt}y_{jt} +
    c_{jt}x_{jt} + h_{jt}s_{jt}) \\
            &amp; s.t. &amp; \nonumber \\
            &amp;&amp; \displaystyle \sum_{j=1}^n a_{jt}x_{jt}+m_{jt}y_{jt} \leq
            b_t, \quad \forall t \\
            &amp;&amp; x_{jt} + s_{jt-1} - s_{jt} = d_{jt}, \quad \forall j,t \\
            &amp;&amp; x_{jt} \leq M y_{jt}, \quad \forall j,t \\
            &amp;&amp; y_{jt} \in \left\{0,1\right\}, x_{jt}, s_{jt} \geq 0
\end{eqnarray}"/></p>
</div><p>To address the problem using Benders decomposition, we define a master, which
includes the <em>difficult</em> binary variables <img class="math" src="_images/math/7e65b69d8d4a3093c7896dd1ab16b1966fcde877.png" alt="y_{jt}"/>, and a subproblem,
which deals with the continuous variables <img class="math" src="_images/math/f5f61982192147d15f4cf63879cc659b7daf7aa0.png" alt="x_{jt}, s_{jt}"/>.</p>
<div class="section" id="master-problem">
<h3>Master Problem<a class="headerlink" href="#master-problem" title="Permalink to this headline">¶</a></h3>
<p>The master is:</p>
<div class="math">
<p><img src="_images/math/4f5cbbf1a5fb575b91393e9ece0d0ac04abe6b10.png" alt="\begin{eqnarray}
   \max     &amp;&amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T f_{jt}y_{jt} + z\\
            &amp; s.t. &amp; \nonumber \\
            &amp;&amp; z \geq \phi(\mathbf{y}) \\
            &amp;&amp; y_{jt} \in \left\{0,1\right\}
\end{eqnarray}"/></p>
</div><p>where <img class="math" src="_images/math/87d649494461366e1eb08e093a10bd909c4ea8c0.png" alt="\phi(\mathbf{y})"/> is the best possible cost obtained for a given
<img class="math" src="_images/math/c466316585a9a1c0a5137f093313c8ff5e5d329b.png" alt="\mathbf{y}"/>.</p>
</div>
<div class="section" id="subproblem">
<h3>Subproblem<a class="headerlink" href="#subproblem" title="Permalink to this headline">¶</a></h3>
<p>Given a solution to the master problem <img class="math" src="_images/math/10de9fb08e39a54cd60f7035c6915df992c18094.png" alt="\mathbf{y}^*"/>, we define a primal
subproblem as:</p>
<div class="math">
<p><img src="_images/math/686dcae9076e8dd21f3573b794f6850e2bfd1cbc.png" alt="\begin{eqnarray}
   \max     &amp; &amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T c_{jt}x_{jt} + h_{jt}s_{jt} \\
            &amp; s.t. &amp; \nonumber \\
            &amp;&amp; \displaystyle \sum_{j=1}^n a_{jt}x_{jt}\leq
            b_t - m_{jt}y_{jt}^* , \quad \forall t \\
            &amp;&amp; x_{jt} + s_{jt-1} - s_{jt} = d_{jt}, \quad \forall j,t \\
            &amp;&amp; x_{jt} \leq M y_{jt}^*, \quad \forall j,t \\
            &amp;&amp; x_{jt}, s_{jt} \geq 0
\end{eqnarray}"/></p>
</div><p>Note that the subproblem is an LP and, therefore, can easily be solved using
cplex. Once the subproblem is solved, we obtain the optimal dual values.</p>
<p>Assume we have:</p>
<ul class="simple">
<li><img class="math" src="_images/math/0afffa4a24169745c72fd2cbc3ad66c21eefac47.png" alt="\lambda_t"/>: The dual values of the capacity constraints (2)</li>
<li><img class="math" src="_images/math/e556375c4157d240fad9f0f4284b22d3062a3f88.png" alt="\omega_{jt}"/>: The dual values of the demand constraints (3)</li>
<li><img class="math" src="_images/math/8698aa13b88ef0deca508a7694d2aa881c8d959a.png" alt="\nu{jt}"/>: The dual values of the logical constraints (4)</li>
</ul>
<p>Then, we write the benders cut as follows:</p>
<div class="math">
<p><img src="_images/math/0960e3963eded339dc84c93df4a653e61ca4bf25.png" alt="\displaystyle z \geq \sum_{t=1}^T \left( b_t - \sum_{j=1}^n m_{jt}y_{jt} \right)
+ \sum_{j=1}^n \sum_{t=1}^T d_{jt}\omega_{jt} + \sum_{j=1}^n \sum_{t=1}^T
M\nu_{jt}y_{jt}

\sum_{j=1}^n \sum_{t=1}^T y_{jt} \left(M\nu_{jt} - \lambda_t m_{jt} \right) -z \leq
- \sum_{t=1}^t \lambda_t b_t - \sum_{j=1}^n \sum_{t=1}^T \omega_{jt} d_{jt}"/></p>
</div></div>
<div class="section" id="alternative-formulation-based-on-the-support-function">
<h3>Alternative Formulation Based on the Support Function<a class="headerlink" href="#alternative-formulation-based-on-the-support-function" title="Permalink to this headline">¶</a></h3>
<p>(Based on Floudas, Non-linear and Mixed-integer Programming, Ch.6)</p>
<p>The general master program is:</p>
<div class="math">
<p><img src="_images/math/cf571c3b852399138b92ed5a2460f13f21a9e34d.png" alt="\begin{eqnarray}
   \max     &amp;&amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T f_{jt}y_{jt} + z\\
            &amp; s.t. &amp; \nonumber \\
            &amp;&amp; z \geq L(x,y,s,\lambda, \nu) \quad \forall \lambda, \nu \\
            &amp;&amp; 0 \geq L(x,y,s,\bar{\lambda}, \bar{\nu}) \quad \forall
            \bar{\lambda}, \bar{\nu} \\
            &amp;&amp; y_{jt} \in \left\{0,1\right\}
\end{eqnarray}"/></p>
</div><p>where constraints (2) are <em>optimality cuts</em>, while constraints (3) are
<em>feasibility cuts</em>. In this work, we ignore the feasility cuts, due to the use
of initial inventory variables <code class="docutils literal"><span class="pre">sI</span></code>. Now, since the above formulation
requires the definition of all the possible value of <img class="math" src="_images/math/1ab0134b6e0837594649c75a2ed83cfd85a2d03d.png" alt="\lambda"/> and
<img class="math" src="_images/math/126e84ba38f7dece5f0ad64e929b9588b20f6440.png" alt="\mu"/>, we solve a <strong>relaxation</strong> of the master problem. Therefore, at
every iteration, the master provides a <strong>lower bound</strong> of the optimal value.</p>
<p>The master contains, as constraints, two inner optimization problems. We
express the inner minimization problem in terms of <strong>support function</strong>, i.e</p>
<div class="math">
<p><img src="_images/math/6f0d0cd9e99789b92dbceb6654a68e111002d330.png" alt="\xi (y,\lambda, \nu) = \min_{x \in X} L(x,y,\lambda, \nu)"/></p>
</div><p>Using ideas from Geoffrion (1972), we consider the case of linearly separable
functions in <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> and <img class="math" src="_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/>, i.e., the objective function
<img class="math" src="_images/math/ffff1d6f584601767db4e06b7c6e648c87a7a00a.png" alt="f(x,y)"/> and the constraints <img class="math" src="_images/math/dc31782c97f9ec5c4bc8e641ac31cd8b1df39fa8.png" alt="g_k(x,y)"/> can be separated. In this
case, the optimalit cut is:</p>
<div class="math">
<p><img src="_images/math/d2d340549a36ad4bf28e0fb79c4a779da36bc0c0.png" alt="z \geq \displaystyle \sum_{j=1}^n \sum_{t=1}^T \left(-m_{jt}\lambda_t +
M\nu_{jt} \right)\times \left( y_{jt} - y_{jt}^*\right) + z_{s}"/></p>
</div><p>where <img class="math" src="_images/math/6b2b84ed9a056278194c56655e989af3790f6dc7.png" alt="z_{s}"/> is the optimal objective function value of the last
subproblem, and <img class="math" src="_images/math/c33e96850f68f20eb8846d19bddf7cd92174c716.png" alt="y^*"/> indicates the current optimal solution of the
master problem.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The dual values have positive sign here, since they are treated as
Lagrangean multipliers (this is the reason why the sign is reversed.)</p>
</div>
</div>
</div>
<div class="section" id="how-to-run-this-code">
<h2>How to Run This Code<a class="headerlink" href="#how-to-run-this-code" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="#clspBenders.parseCommandLine" title="clspBenders.parseCommandLine"><code class="xref py py-func docutils literal"><span class="pre">parseCommandLine()</span></code></a>.</p>
</div>
<div class="section" id="history">
<h2>History<a class="headerlink" href="#history" title="Permalink to this headline">¶</a></h2>
<p>15.03.17:</p>
<blockquote>
<div>The problem seems to be that the lower bound provided by the master is not
tight. I attempted to tighten the bound, by adding constraints linking
(somehow) the variables <img class="math" src="_images/math/7e65b69d8d4a3093c7896dd1ab16b1966fcde877.png" alt="y_{jt}"/> with <img class="math" src="_images/math/54af3546ece177debc6a3d3c79d416ef05016e94.png" alt="x_{jt}"/>, but no
improvement is observed. I tried a constraint that ensures that the number
of <img class="math" src="_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/> variables set to 1 is enough to covere the total demand. The
constraint seems to be correct, but no improvement is observed with respect
to the lower bound of the master.</div></blockquote>
<p>23.03.17:</p>
<blockquote>
<div>Added user cuts, to get cuts for fractional values of y* as well.</div></blockquote>
</div>
<div class="section" id="redefinition-based-on-spl">
<h2>Redefinition based on SPL<a class="headerlink" href="#redefinition-based-on-spl" title="Permalink to this headline">¶</a></h2>
<p>A modified version of this code is presented here. Basically, two important
changes have been introduced:</p>
<p>1. We use the Simple Plant Location (SPL) reformulation for the Lot Sizing
problem 
2. Rather than relying on LazyConstraintCallback(), we now implement a cycle
to define Benders&#8217; scheme, with iterative calls to master and subproblems.</p>
<p>The following is the SPL reformulation:</p>
<div class="math">
<p><img src="_images/math/672f4ffb571fe465a670b5fb224be03d14c6e9d1.png" alt="\begin{eqnarray}
  &amp; \min z = &amp;   \sum_{j=1}^n \sum_{t=1}^T f_{jt}y_{jt} +
  \sum_{j=1}^n \sum_{r=1}^T \sum_{t=1}^{r-1} h_{jtr}z_{jtr}
  \label{eq:SPL-obj}\\
  &amp;\mbox{s.t} &amp; \sum_{j=1}^n \left(a_{jt}\sum_{r=t}^T z_{jtr} +
  m_{jt}y_{jt}\right) \leq b_t,
  \quad t = 1, \ldots, T \label{eq:SPL-capacity-constr} \\
  &amp;&amp;  \sum_{t=1}^r z_{jtr} = d_{jr},
  \quad j = 1, \ldots, n , \quad r = 1, \dots, T \label{eq:SPL-demand-constr}
  \\
  &amp;&amp; z_{jtr} \leq d_{jr}y_{jt},
  \quad j = 1, \ldots, n , \quad t = 1, \dots, T, \quad r=t,\dots,T
  \label{eq:SPL-logic-constr} \\
  &amp;&amp; \sum_{r=t}^T z_{jtr} \leq M y_{jt},
  \quad j = 1, \ldots, n , \quad t = 1, \dots, T \\
  &amp;&amp; y_{jt} \in \left\{0,1\right\}, \quad j = 1, \ldots, n, \quad
  t=1, \ldots, T \label{eq:SPL-y-binary}\\
  &amp;&amp; z_{jtr} \geq 0, \quad j = 1, \ldots, n, \quad
  t=1, \ldots, T, \quad r = t,\dots,T \label{eq:SPL-z-cont}
\end{eqnarray}"/></p>
</div><p>where we define <img class="math" src="_images/math/2a4734659057d49a6f2a5d680caf3143e6d289b8.png" alt="h_{jtr} = \sum_{t'=t}^{r-1} h_{jt'}"/> as the
cumulative cost of keeping in inventory a unit of item <em>j</em> from period <em>t</em> to
period <em>r-1</em>.</p>
<p>The separation scheme and, consequently, the construction of master and
subproblems is as before. However, the main change here concerns the use of a
cycle to iteratively solve the master and the subproblems.</p>
<p>We call <a class="reference internal" href="#clspBenders.benderAlgorithm" title="clspBenders.benderAlgorithm"><code class="xref py py-func docutils literal"><span class="pre">benderAlgorithm()</span></code></a>, which is a function that implements the cycle.
Before doing that, we might apply some fixing schemes (both to zero and to one)
based on the LP relaxation. See functions <a class="reference internal" href="#clspBenders.MIP.solveLPOne" title="clspBenders.MIP.solveLPOne"><code class="xref py py-meth docutils literal"><span class="pre">MIP.solveLPOne()</span></code></a> and
<a class="reference internal" href="#clspBenders.MIP.solveLPZero" title="clspBenders.MIP.solveLPZero"><code class="xref py py-meth docutils literal"><span class="pre">MIP.solveLPZero()</span></code></a>.</p>
<dl class="class">
<dt id="clspBenders.BendersLazyConsCallback">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">BendersLazyConsCallback</code><span class="sig-paren">(</span><em>env</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#BendersLazyConsCallback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.BendersLazyConsCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">cplex.callbacks.LazyConstraintCallback</span></code></p>
<p>This is the LazyConstraintCallback of cplex. We implement Benders algorithm
via callback. That it, the master is solved within a branch and bound
framework and, every time a new master solution is obtained, the callback
is used to:</p>
<ul class="simple">
<li>get the master solution <img class="math" src="_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/></li>
<li>pass it to the subproblem to obtain <img class="math" src="_images/math/24cbfcb15f060dfe37714f32b8b9e68e59f6b860.png" alt="\phi(y)"/></li>
<li>get the dual values and define Benders cut</li>
<li>add the cut to the master</li>
<li>give control back to cplex</li>
</ul>
</dd></dl>

<dl class="class">
<dt id="clspBenders.BendersUserCutCallback">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">BendersUserCutCallback</code><span class="sig-paren">(</span><em>env</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#BendersUserCutCallback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.BendersUserCutCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">cplex.callbacks.UserCutCallback</span></code></p>
</dd></dl>

<dl class="class">
<dt id="clspBenders.Instance">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">Instance</code><span class="sig-paren">(</span><em>inputfile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#Instance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.Instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class used to read the instance from a disk file.
Instances are obtained from Trigeiro. We also compute a tight value for the
big M constant, as well as a cumulative demand value for t to T.</p>
</dd></dl>

<dl class="class">
<dt id="clspBenders.MIP">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">MIP</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#MIP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.MIP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Define the full model and solve it using cplex. We use this class to
compute optimal values of the full MIP models and compare them, along with
the achieve performance, with the Benders approach.</p>
<p>This is the Standard Lot Sizing implementation, using variables
<img class="math" src="_images/math/b764cb200d7d86a31476dcbb81c53623bc4de3a2.png" alt="y_{jt}, x_{jt}, s_{jt}"/>. This formulation is no longer used in the
current version of the code, since the SPL reformulation provides tighter
relaxations.</p>
<dl class="method">
<dt id="clspBenders.MIP.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>inp</em>, <em>nSol=99999</em>, <em>withPool=0</em>, <em>withPrinting=0</em>, <em>display=0</em>, <em>timeLimit=10000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#MIP.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.MIP.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the original MIMPLS using cplex branch and bound. A number of
flags can be activate, to control the behavior of the solver:</p>
<ul class="simple">
<li>nSol : maximum number of solutions to be visited</li>
<li>withPool : collect a pool of solutions during the optimization phase</li>
<li>withPrinting: control the output</li>
<li>display : control cplex output</li>
<li>timeLimit : set a maximum time limit</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="clspBenders.MIP.solveLPOne">
<code class="descname">solveLPOne</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#MIP.solveLPOne"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.MIP.solveLPOne" title="Permalink to this definition">¶</a></dt>
<dd><p>Same idea presented in <a class="reference internal" href="#clspBenders.MIP.solveLPZero" title="clspBenders.MIP.solveLPZero"><code class="xref py py-func docutils literal"><span class="pre">solveLPZero()</span></code></a>. See comment above.</p>
</dd></dl>

<dl class="method">
<dt id="clspBenders.MIP.solveLPZero">
<code class="descname">solveLPZero</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#MIP.solveLPZero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.MIP.solveLPZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve LP relaxation of original MIP twice:</p>
<ul class="simple">
<li>the first time, we solve the LP relaxation of the whole problem, and
we store the variables whose value is zero in the LP solution
(indexLP1)</li>
<li>the second time, we add a &#8220;corridor&#8221; type of constraint to the LP,
enforcing that at least a given number of variables in indexLP1 will
change value, i.e., will take a value above 0. We store in indexLP2
the variables that take value zero in the LP-constrained model.</li>
<li>the intersection between indexLP1 and indexLP2 gives the set of
variables we want to keep fixed to zero.</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="clspBenders.MIPReformulation">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">MIPReformulation</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#MIPReformulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.MIPReformulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#clspBenders.MIP" title="clspBenders.MIP"><code class="xref py py-class docutils literal"><span class="pre">clspBenders.MIP</span></code></a></p>
<p>This class implements the SPL reformulation, which is the one currently
used in the code. The reformulation has been presented in the introduction
of this code and makes use of two sets of variables, i.e.:</p>
<ul class="simple">
<li><img class="math" src="_images/math/7e65b69d8d4a3093c7896dd1ab16b1966fcde877.png" alt="y_{jt}"/> : setup variables</li>
<li><img class="math" src="_images/math/08cd8a31fe62980f63605653aa1d76cbd6b00520.png" alt="z_{jtr}"/>: production variables, indicating the amount of production of item <em>j</em> produced in period <em>t</em> to satisfy the demand of period <em>r</em>. Obviously, <img class="math" src="_images/math/040ee59b3f08ceec3020c5659b28c4b522519d40.png" alt="z_{jtr} = 0"/> for all <em>t&gt;r</em>.</li>
</ul>
</dd></dl>

<dl class="class">
<dt id="clspBenders.SolveNodeCallback">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">SolveNodeCallback</code><span class="sig-paren">(</span><em>env</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#SolveNodeCallback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.SolveNodeCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">cplex.callbacks.SimplexCallback</span></code></p>
</dd></dl>

<dl class="class">
<dt id="clspBenders.WorkerLP">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">WorkerLP</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#WorkerLP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.WorkerLP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Define and solve the subproblem. We initilize the subproblem with the right
hand side values of the constraints to zero, since we assume the initial
values of <img class="math" src="_images/math/7e65b69d8d4a3093c7896dd1ab16b1966fcde877.png" alt="y_{jt}"/> to be equal to zero. Next, within the
<a class="reference internal" href="#clspBenders.WorkerLP.separate" title="clspBenders.WorkerLP.separate"><code class="xref py py-meth docutils literal"><span class="pre">WorkerLP.separate()</span></code></a> function, we define the rhs values to the 
correct values, depending on the solution obtained from the master.</p>
<p>Cplex requires the presolve reductions to be turned off, using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">reduce</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition, we need to ensure that the LP is <em>not</em> solved using the
interior point method, otherwise dual values won&#8217;t be available. We can
either use primal simplex or dual simplex.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The subproblem constraints should be defined with a name, in
order to be able to recall the precise name of each constraint when we 
want to obtain the dual values. Briefly, we need to:</p>
<ul class="last">
<li><p class="first">define a unique name for each constraint, e.g., <code class="docutils literal"><span class="pre">capacity.t</span></code> for each t</p>
</li>
<li><p class="first">store such names in a vector of names, e.g,:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">lCapacity</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;capacity.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p class="first">get the dual values using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dCapacity</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lCapacity</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<dl class="method">
<dt id="clspBenders.WorkerLP.separate">
<code class="descname">separate</code><span class="sig-paren">(</span><em>inp</em>, <em>ySol</em>, <em>zHat</em>, <em>y_ilo</em>, <em>z_ilo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#WorkerLP.separate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.WorkerLP.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the <em>old</em> implementation, based on the standard Lot Sizing
formulation. Here is were Benders cut is obtained and passed to the master.</p>
<p>The following steps describe the algorithm:</p>
<ul class="simple">
<li>update rhs values of the subproblem, i.e., using the current optimal solution of the master problem <img class="math" src="_images/math/c33e96850f68f20eb8846d19bddf7cd92174c716.png" alt="y^*"/></li>
<li>solve the subproblem</li>
<li>get the dual values <img class="math" src="_images/math/a28e404e76b0c6a2ee03ebc4e3a3ad8c05c8c893.png" alt="\lambda, \nu"/></li>
<li>generate cut (lhs and rhs) and store them in a constraint structure</li>
<li>pass the cut to the master</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="clspBenders.WorkerLPReformulation">
<em class="property">class </em><code class="descclassname">clspBenders.</code><code class="descname">WorkerLPReformulation</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#WorkerLPReformulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.WorkerLPReformulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="clspBenders.WorkerLPReformulation.formulateDual">
<code class="descname">formulateDual</code><span class="sig-paren">(</span><em>cpx</em>, <em>inp</em>, <em>ySol</em>, <em>w_ilo</em>, <em>l_ilo</em>, <em>v_ilo</em>, <em>e_ilo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#WorkerLPReformulation.formulateDual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.WorkerLPReformulation.formulateDual" title="Permalink to this definition">¶</a></dt>
<dd><p>Formulation of the subproblem dual. This is no longer used, but I leave
it here for the sake of completeness. I checked that the formulation is
correct, since the objective function value of the optimal dual is
identical to that of the optimal primal.</p>
</dd></dl>

<dl class="method">
<dt id="clspBenders.WorkerLPReformulation.paretoOptimal">
<code class="descname">paretoOptimal</code><span class="sig-paren">(</span><em>inp</em>, <em>ySol</em>, <em>zDual</em>, <em>zHat</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#WorkerLPReformulation.paretoOptimal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.WorkerLPReformulation.paretoOptimal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get pareto optimal cuts. See paper for an explanation. In principle,
this should be helpful, since the dual problem is degenerate and,
consequently, multiple optimal solutions should exist. This means that
the &#8220;right&#8221; selection of dual values should make a difference in the
strength of the cut. However, the extra effort required to get pareto
optimal cuts does not seem to be compensated by the minor improvement
obtained here.</p>
</dd></dl>

<dl class="method">
<dt id="clspBenders.WorkerLPReformulation.separate">
<code class="descname">separate</code><span class="sig-paren">(</span><em>inp</em>, <em>ySol</em>, <em>zHat</em>, <em>y_ilo</em>, <em>z_ilo_m</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#WorkerLPReformulation.separate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.WorkerLPReformulation.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the separation scheme for the WorkerLPReformulation, i.e., the
SPL reformulation. Here is were Benders cut is obtained and passed to 
the master.</p>
<p>The following steps describe the algorithm:</p>
<ul class="simple">
<li>update rhs values of the subproblem, i.e., using the current optimal solution of the master problem <img class="math" src="_images/math/c33e96850f68f20eb8846d19bddf7cd92174c716.png" alt="y^*"/></li>
<li>solve the subproblem</li>
<li>get the dual values <img class="math" src="_images/math/a28e404e76b0c6a2ee03ebc4e3a3ad8c05c8c893.png" alt="\lambda, \nu"/></li>
<li>generate cut (lhs and rhs) and store them in a constraint structure</li>
<li>pass the cut to the master</li>
</ul>
<p>Advanced cplex functions are used here, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">farkas</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">advanced</span><span class="o">.</span><span class="n">dual_farkas</span><span class="p">()</span>
</pre></div>
</div>
<p>to get Farkas certificates used to get the extreme rays, and:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dCapacity</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lCapacity</span><span class="p">)</span>
</pre></div>
</div>
<p>to get the dual values, which are used in the creation of optimality
cuts.</p>
</dd></dl>

<dl class="method">
<dt id="clspBenders.WorkerLPReformulation.solveDual">
<code class="descname">solveDual</code><span class="sig-paren">(</span><em>inp</em>, <em>ySol</em>, <em>zHat</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#WorkerLPReformulation.solveDual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.WorkerLPReformulation.solveDual" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dual problem (i.e., an explicit way of obtained the dual
values needed to create the optimality cut. It is no longer used.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="clspBenders.addCorridor">
<code class="descclassname">clspBenders.</code><code class="descname">addCorridor</code><span class="sig-paren">(</span><em>inp</em>, <em>cpx</em>, <em>ySol</em>, <em>y_ilo</em>, <em>cWidth</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#addCorridor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.addCorridor" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements the corridor method for Benders&#8217; decomposition.
The idea can be described as follows: Every time a new incumbent solution
is found by the subproblem (i.e., a feasible solution which improves the
upper bound), a new best solution is obtained. Let us indicate with <img class="math" src="_images/math/04232560ef1edc371edd9306dfe123249eacdd11.png" alt="y^I"/> 
such solution. After adding the corresponding optimality cut to the master,
we also impose the following corridor constraint:</p>
<div class="math">
<p><img src="_images/math/932b4fe059c7c698ee08d7c650d0ce1adae25fdd.png" alt="\begin{equation}
\sum_{t=1}^T y^I_{jt}\left(1-y_{jt}\right) + \left(1-y^I_{jt}\right)y_{jt} \leq
\gamma nT
\end{equation}"/></p>
</div><p>which ensure that no more than <img class="math" src="_images/math/0ebb67342b546ca42a1c634b1ef03c893c4cdedb.png" alt="\gamma"/> percent of the setup
variables will change value. This approach imposes a maximum hamming
distance with respect to the incumbent solution, thus
restricting the solution space of the master problem. This allows to speed up
the convergence of Benders&#8217; algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="clspBenders.barrierInit">
<code class="descclassname">clspBenders.</code><code class="descname">barrierInit</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#barrierInit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.barrierInit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clspBenders.benderAlgorithm">
<code class="descclassname">clspBenders.</code><code class="descname">benderAlgorithm</code><span class="sig-paren">(</span><em>inp</em>, <em>fixToZero</em>, <em>fixToOne</em>, <em>cPercent</em>, <em>cZero</em>, <em>cOne</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#benderAlgorithm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.benderAlgorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements Benders&#8217; scheme without the use of callbacks. We
thus define a cycle that iteratively solves the master and the subproblems,
until a termination criterion is reached.</p>
<p>The current implementation is heuristic in nature, since fixing schemes as
well as a corridor are used. Therefore, there is no guarantee that the
solution returned by this algorithm is optimal. To get an exact approach,
deactivate the fixing schemes (to zero and to one) and the corridor scheme.</p>
<p>We make use of an in-out cycle, in a fashion similar to what has been done
by Fischetti for the uncapacitated facility location problem (see their MS
paper.) Probably, this part could be improved, to make it faster. However,
it seems important to reach a good lower bound quickly. If the in-out cycle
is not used, the lower bound is much worse and the convergence is extremely
slow.</p>
<p>Another feature of the Benders&#8217; implementation is connected with the use of
a pool of solutions. Before calling Benders&#8217; algorithm, we heuristically
solve the original CLSP with a maximum number of solutions to be reached.
During this call to cplex, we collect a <em>pool</em> of solutions, which can be
used to tighten the master. The idea is that we then pass these solutions
to the separation scheme. Alternative approaches have been explored, e.g.,
producing feasible solutions using a Cross Entropy scheme and, then, apply
the separation mechanism to each of these solutions. To get the pool of
solution, it suffices to call <a class="reference internal" href="#clspBenders.MIP.solve" title="clspBenders.MIP.solve"><code class="xref py py-meth docutils literal"><span class="pre">MIP.solve()</span></code></a> with the flag <code class="docutils literal"><span class="pre">withPool=1</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="clspBenders.createMaster">
<code class="descclassname">clspBenders.</code><code class="descname">createMaster</code><span class="sig-paren">(</span><em>inp</em>, <em>cpx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#createMaster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.createMaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Create benders master problem. In reality, this is a <em>relaxation</em> of the
master, to which we progressively add cuts.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The master problem provides a <strong>lower bound</strong> to the optimal
solution.</p>
</div>
<p>Here we try different methods to tighen the lower bound.</p>
</dd></dl>

<dl class="function">
<dt id="clspBenders.findNext">
<code class="descclassname">clspBenders.</code><code class="descname">findNext</code><span class="sig-paren">(</span><em>j</em>, <em>t</em>, <em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#findNext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.findNext" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clspBenders.fixingToZero">
<code class="descclassname">clspBenders.</code><code class="descname">fixingToZero</code><span class="sig-paren">(</span><em>inp</em>, <em>cpx</em>, <em>bestLB</em>, <em>bestUB</em>, <em>y_ilo</em>, <em>yFixed</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#fixingToZero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.fixingToZero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clspBenders.getSolution">
<code class="descclassname">clspBenders.</code><code class="descname">getSolution</code><span class="sig-paren">(</span><em>inp</em>, <em>cpx</em>, <em>y_ilo</em>, <em>z_ilo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#getSolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.getSolution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clspBenders.getUB">
<code class="descclassname">clspBenders.</code><code class="descname">getUB</code><span class="sig-paren">(</span><em>inp</em>, <em>zSub</em>, <em>ySol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#getUB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.getUB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clspBenders.inOutCycle">
<code class="descclassname">clspBenders.</code><code class="descname">inOutCycle</code><span class="sig-paren">(</span><em>cpx</em>, <em>worker</em>, <em>y_ilo</em>, <em>z_ilo</em>, <em>inp</em>, <em>globalProgr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#inOutCycle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.inOutCycle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clspBenders.inOutCycle2">
<code class="descclassname">clspBenders.</code><code class="descname">inOutCycle2</code><span class="sig-paren">(</span><em>cpx</em>, <em>worker</em>, <em>y_ilo</em>, <em>z_ilo</em>, <em>inp</em>, <em>globalProgr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#inOutCycle2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.inOutCycle2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clspBenders.main">
<code class="descclassname">clspBenders.</code><code class="descname">main</code><span class="sig-paren">(</span><em>argv</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#main"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Entry point.</p>
<p>We first parse the command line, then reading the instance from a disk
file.</p>
<p>The algorithm to be used is selected via command line using flag -a. See
<a class="reference internal" href="#clspBenders.parseCommandLine" title="clspBenders.parseCommandLine"><code class="xref py py-func docutils literal"><span class="pre">parseCommandLine()</span></code></a> for more details on flags and options for this
code.</p>
<p>With respect to the type of algorithms that can be used, we have:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Benders Decomposition</li>
<li>Lagrangean Relaxation</li>
<li>Dantzig-Wolfe</li>
<li>Cplex MIP solver</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="clspBenders.parseCommandLine">
<code class="descclassname">clspBenders.</code><code class="descname">parseCommandLine</code><span class="sig-paren">(</span><em>argv</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#parseCommandLine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.parseCommandLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse command line. Options are:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-h <var>help</var></span></kbd></td>
<td>usage help</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-i <var>inputfile</var></span></kbd></td>
<td>instance file name</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-u <var>userCuts</var></span></kbd></td>
<td>activate user cuts (fractional values)</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-c <var>cpercent</var></span></kbd></td>
<td>corridor width</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-z <var>zeros</var></span></kbd></td>
<td>soft fixing to zero</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-o <var>ones</var></span></kbd></td>
<td>soft fixing to one</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-a <var>algorithm</var></span></kbd></td>
<td>type of algorithm used:</td></tr>
</tbody>
</table>
<p>With respect to the type of algorithms that can be used, we have:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Benders Decomposition</li>
<li>Lagrangean Relaxation</li>
<li>Dantzig-Wolfe</li>
<li>Cplex MIP solver</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="clspBenders.setCpxParameters">
<code class="descclassname">clspBenders.</code><code class="descname">setCpxParameters</code><span class="sig-paren">(</span><em>cpx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/clspBenders.html#setCpxParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#clspBenders.setCpxParameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">clspBenders module</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#master-problem">Master Problem</a></li>
<li><a class="reference internal" href="#subproblem">Subproblem</a></li>
<li><a class="reference internal" href="#alternative-formulation-based-on-the-support-function">Alternative Formulation Based on the Support Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-run-this-code">How to Run This Code</a></li>
<li><a class="reference internal" href="#history">History</a></li>
<li><a class="reference internal" href="#redefinition-based-on-spl">Redefinition based on SPL</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to MIMPLS Benders documentation!</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dw2.html"
                        title="next chapter">dw2 module</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/clspBenders.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dw2.html" title="dw2 module"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to MIMPLS Benders documentation!"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MIMPLS Benders 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Marco Caserta.
      Last updated on Jun 01, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>