<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>clspBenders &#8212; MIMPLS Benders 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MIMPLS Benders 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for clspBenders</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">===========================================================================</span>

<span class="sd">:Filename: clspBenders.py</span>
<span class="sd">:Author: marco caserta</span>
<span class="sd">:Date: 09.03.2017</span>
<span class="sd">:Last Update: |date|</span>

<span class="sd">.. |date| date:: %d.%m.%y</span>
<span class="sd">.. |time| date:: %H:%M</span>

<span class="sd">Copyright (C) 2017 by Marco Caserta  (marco dot caserta at ie dot edu)</span>

<span class="sd">(This document was generated on |date| at |time|.)</span>

<span class="sd">.. this is just a comment</span>

<span class="sd">===========================================================================</span>

<span class="sd">   This program is free software; you can redistribute it and/or modify it</span>
<span class="sd">   under the terms of the GNU General Public License as published by the Free</span>
<span class="sd">   Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="sd">   any later version.</span>

<span class="sd">   This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="sd">   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="sd">   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="sd">   more details.</span>

<span class="sd">   You should have received a copy of the GNU General Public License along with</span>
<span class="sd">   this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="sd">   Place - Suite 330, Boston, MA  02111-1307, USA.</span>

<span class="sd">===========================================================================</span>

<span class="sd">Introduction</span>
<span class="sd">------------</span>

<span class="sd">**NOTE**: A completely modified version of this code is presented below.</span>

<span class="sd">This code implements a simple benders decomposition scheme for the</span>
<span class="sd">multi-item multi-period capacitated lot sizing problem. Benders cuts are added</span>
<span class="sd">via LazyConstraintCallback(). The case of an infeasibility cut is not</span>
<span class="sd">considered, since the subproblem is always feasible (due to the possibility</span>
<span class="sd">to choose an arbitrarily large value for the initial inventory level.) This</span>
<span class="sd">should be improved adding a cut based on extreme rays.</span>

<span class="sd">The following is a formulation for the MIMPLS:</span>

<span class="sd">.. math ::</span>
<span class="sd">    :nowrap:</span>

<span class="sd">    \\begin{eqnarray}</span>
<span class="sd">       \max     &amp; &amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T (f_{jt}y_{jt} +</span>
<span class="sd">        c_{jt}x_{jt} + h_{jt}s_{jt}) \\\\</span>
<span class="sd">                &amp; s.t. &amp; \\nonumber \\\\</span>
<span class="sd">                &amp;&amp; \displaystyle \sum_{j=1}^n a_{jt}x_{jt}+m_{jt}y_{jt} \leq</span>
<span class="sd">                b_t, \quad \\forall t \\\\</span>
<span class="sd">                &amp;&amp; x_{jt} + s_{jt-1} - s_{jt} = d_{jt}, \quad \\forall j,t \\\\</span>
<span class="sd">                &amp;&amp; x_{jt} \leq M y_{jt}, \quad \\forall j,t \\\\</span>
<span class="sd">                &amp;&amp; y_{jt} \in \left\{0,1\\right\}, x_{jt}, s_{jt} \geq 0</span>
<span class="sd">    \end{eqnarray}</span>

<span class="sd">To address the problem using Benders decomposition, we define a master, which</span>
<span class="sd">includes the *difficult* binary variables :math:`y_{jt}`, and a subproblem,</span>
<span class="sd">which deals with the continuous variables :math:`x_{jt}, s_{jt}`.</span>

<span class="sd">Master Problem</span>
<span class="sd">~~~~~~~~~~~~~~</span>

<span class="sd">The master is:</span>

<span class="sd">.. math ::</span>
<span class="sd">    :nowrap:</span>

<span class="sd">    \\begin{eqnarray}</span>
<span class="sd">       \max     &amp;&amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T f_{jt}y_{jt} + z\\\\</span>
<span class="sd">                &amp; s.t. &amp; \\nonumber \\\\</span>
<span class="sd">                &amp;&amp; z \geq \phi(\mathbf{y}) \\\\</span>
<span class="sd">                &amp;&amp; y_{jt} \in \left\{0,1\\right\}</span>
<span class="sd">    \end{eqnarray}</span>

<span class="sd">where :math:`\phi(\mathbf{y})` is the best possible cost obtained for a given</span>
<span class="sd">:math:`\mathbf{y}`.</span>

<span class="sd">Subproblem</span>
<span class="sd">~~~~~~~~~~</span>

<span class="sd">Given a solution to the master problem :math:`\mathbf{y}^*`, we define a primal</span>
<span class="sd">subproblem as:</span>

<span class="sd">.. math ::</span>
<span class="sd">    :nowrap:</span>

<span class="sd">    \\begin{eqnarray}</span>
<span class="sd">       \max     &amp; &amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T c_{jt}x_{jt} + h_{jt}s_{jt} \\\\</span>
<span class="sd">                &amp; s.t. &amp; \\nonumber \\\\</span>
<span class="sd">                &amp;&amp; \displaystyle \sum_{j=1}^n a_{jt}x_{jt}\leq</span>
<span class="sd">                b_t - m_{jt}y_{jt}^* , \quad \\forall t \\\\</span>
<span class="sd">                &amp;&amp; x_{jt} + s_{jt-1} - s_{jt} = d_{jt}, \quad \\forall j,t \\\\</span>
<span class="sd">                &amp;&amp; x_{jt} \leq M y_{jt}^*, \quad \\forall j,t \\\\</span>
<span class="sd">                &amp;&amp; x_{jt}, s_{jt} \geq 0</span>
<span class="sd">    \end{eqnarray}</span>

<span class="sd">Note that the subproblem is an LP and, therefore, can easily be solved using</span>
<span class="sd">cplex. Once the subproblem is solved, we obtain the optimal dual values.</span>

<span class="sd">Assume we have:</span>

<span class="sd">* :math:`\lambda_t`: The dual values of the capacity constraints (2)</span>
<span class="sd">* :math:`\omega_{jt}`: The dual values of the demand constraints (3)</span>
<span class="sd">* :math:`\\nu{jt}`: The dual values of the logical constraints (4)</span>

<span class="sd">Then, we write the benders cut as follows:</span>

<span class="sd">.. math ::</span>

<span class="sd">    \displaystyle z \geq \sum_{t=1}^T \left( b_t - \sum_{j=1}^n m_{jt}y_{jt} \\right)</span>
<span class="sd">    + \sum_{j=1}^n \sum_{t=1}^T d_{jt}\omega_{jt} + \sum_{j=1}^n \sum_{t=1}^T</span>
<span class="sd">    M\\nu_{jt}y_{jt}</span>

<span class="sd">    \sum_{j=1}^n \sum_{t=1}^T y_{jt} \left(M\\nu_{jt} - \lambda_t m_{jt} \\right) -z \leq</span>
<span class="sd">    - \sum_{t=1}^t \lambda_t b_t - \sum_{j=1}^n \sum_{t=1}^T \omega_{jt} d_{jt}</span>


<span class="sd">Alternative Formulation Based on the Support Function</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">(Based on Floudas, Non-linear and Mixed-integer Programming, Ch.6)</span>

<span class="sd">The general master program is:</span>

<span class="sd">.. math ::</span>
<span class="sd">    :nowrap:</span>

<span class="sd">    \\begin{eqnarray}</span>
<span class="sd">       \max     &amp;&amp; \displaystyle \sum_{j=1}^n \sum_{t=1}^T f_{jt}y_{jt} + z\\\\</span>
<span class="sd">                &amp; s.t. &amp; \\nonumber \\\\</span>
<span class="sd">                &amp;&amp; z \geq L(x,y,s,\lambda, \\nu) \quad \\forall \lambda, \\nu \\\\</span>
<span class="sd">                &amp;&amp; 0 \geq L(x,y,s,\\bar{\lambda}, \\bar{\\nu}) \quad \\forall</span>
<span class="sd">                \\bar{\lambda}, \\bar{\\nu} \\\\</span>
<span class="sd">                &amp;&amp; y_{jt} \in \left\{0,1\\right\}</span>
<span class="sd">    \end{eqnarray}</span>

<span class="sd">where constraints (2) are *optimality cuts*, while constraints (3) are</span>
<span class="sd">*feasibility cuts*. In this work, we ignore the feasility cuts, due to the use</span>
<span class="sd">of initial inventory variables ``sI``. Now, since the above formulation</span>
<span class="sd">requires the definition of all the possible value of :math:`\lambda` and</span>
<span class="sd">:math:`\mu`, we solve a **relaxation** of the master problem. Therefore, at</span>
<span class="sd">every iteration, the master provides a **lower bound** of the optimal value.</span>

<span class="sd">The master contains, as constraints, two inner optimization problems. We</span>
<span class="sd">express the inner minimization problem in terms of **support function**, i.e</span>


<span class="sd">.. math ::</span>

<span class="sd">    \\xi (y,\lambda, \\nu) = \min_{x \in X} L(x,y,\lambda, \\nu)</span>

<span class="sd">Using ideas from Geoffrion (1972), we consider the case of linearly separable</span>
<span class="sd">functions in :math:`x` and :math:`y`, i.e., the objective function</span>
<span class="sd">:math:`f(x,y)` and the constraints :math:`g_k(x,y)` can be separated. In this</span>
<span class="sd">case, the optimalit cut is:</span>

<span class="sd">.. math ::</span>

<span class="sd">    z \geq \displaystyle \sum_{j=1}^n \sum_{t=1}^T \left(-m_{jt}\lambda_t +</span>
<span class="sd">    M\\nu_{jt} \\right)\\times \left( y_{jt} - y_{jt}^*\\right) + z_{s}</span>

<span class="sd">where :math:`z_{s}` is the optimal objective function value of the last</span>
<span class="sd">subproblem, and :math:`y^*` indicates the current optimal solution of the</span>
<span class="sd">master problem.</span>

<span class="sd">.. note::</span>

<span class="sd">    The dual values have positive sign here, since they are treated as</span>
<span class="sd">    Lagrangean multipliers (this is the reason why the sign is reversed.)</span>

<span class="sd">How to Run This Code</span>
<span class="sd">--------------------</span>


<span class="sd">See :func:`parseCommandLine()`.</span>


<span class="sd">History</span>
<span class="sd">-------</span>

<span class="sd">15.03.17:</span>

<span class="sd">    The problem seems to be that the lower bound provided by the master is not</span>
<span class="sd">    tight. I attempted to tighten the bound, by adding constraints linking</span>
<span class="sd">    (somehow) the variables :math:`y_{jt}` with :math:`x_{jt}`, but no</span>
<span class="sd">    improvement is observed. I tried a constraint that ensures that the number</span>
<span class="sd">    of :math:`y` variables set to 1 is enough to covere the total demand. The</span>
<span class="sd">    constraint seems to be correct, but no improvement is observed with respect</span>
<span class="sd">    to the lower bound of the master.</span>

<span class="sd">23.03.17:</span>

<span class="sd">    Added user cuts, to get cuts for fractional values of y* as well.</span>

<span class="sd">Redefinition based on SPL</span>
<span class="sd">-------------------------</span>

<span class="sd">A modified version of this code is presented here. Basically, two important</span>
<span class="sd">changes have been introduced:</span>

<span class="sd">1. We use the Simple Plant Location (SPL) reformulation for the Lot Sizing</span>
<span class="sd">problem </span>
<span class="sd">2. Rather than relying on LazyConstraintCallback(), we now implement a cycle</span>
<span class="sd">to define Benders&#39; scheme, with iterative calls to master and subproblems.</span>

<span class="sd">The following is the SPL reformulation:</span>

<span class="sd">.. math ::</span>
<span class="sd">    :nowrap:</span>

<span class="sd">    \\begin{eqnarray}</span>
<span class="sd">      &amp; \min z = &amp;   \sum_{j=1}^n \sum_{t=1}^T f_{jt}y_{jt} +</span>
<span class="sd">      \sum_{j=1}^n \sum_{r=1}^T \sum_{t=1}^{r-1} h_{jtr}z_{jtr}</span>
<span class="sd">      \label{eq:SPL-obj}\\\\</span>
<span class="sd">      &amp;\mbox{s.t} &amp; \sum_{j=1}^n \left(a_{jt}\sum_{r=t}^T z_{jtr} +</span>
<span class="sd">      m_{jt}y_{jt}\\right) \leq b_t,</span>
<span class="sd">      \quad t = 1, \ldots, T \label{eq:SPL-capacity-constr} \\\\</span>
<span class="sd">      &amp;&amp;  \sum_{t=1}^r z_{jtr} = d_{jr},</span>
<span class="sd">      \quad j = 1, \ldots, n , \quad r = 1, \dots, T \label{eq:SPL-demand-constr}</span>
<span class="sd">      \\\\</span>
<span class="sd">      &amp;&amp; z_{jtr} \leq d_{jr}y_{jt},</span>
<span class="sd">      \quad j = 1, \ldots, n , \quad t = 1, \dots, T, \quad r=t,\dots,T</span>
<span class="sd">      \label{eq:SPL-logic-constr} \\\\</span>
<span class="sd">      &amp;&amp; \sum_{r=t}^T z_{jtr} \leq M y_{jt},</span>
<span class="sd">      \quad j = 1, \ldots, n , \quad t = 1, \dots, T \\\\</span>
<span class="sd">      &amp;&amp; y_{jt} \in \left\{0,1\\right\}, \quad j = 1, \ldots, n, \quad</span>
<span class="sd">      t=1, \ldots, T \label{eq:SPL-y-binary}\\\\</span>
<span class="sd">      &amp;&amp; z_{jtr} \geq 0, \quad j = 1, \ldots, n, \quad</span>
<span class="sd">      t=1, \ldots, T, \quad r = t,\dots,T \label{eq:SPL-z-cont}</span>
<span class="sd">    \end{eqnarray}</span>

<span class="sd">where we define :math:`h_{jtr} = \sum_{t&#39;=t}^{r-1} h_{jt&#39;}` as the</span>
<span class="sd">cumulative cost of keeping in inventory a unit of item *j* from period *t* to</span>
<span class="sd">period *r-1*. </span>

<span class="sd">The separation scheme and, consequently, the construction of master and</span>
<span class="sd">subproblems is as before. However, the main change here concerns the use of a</span>
<span class="sd">cycle to iteratively solve the master and the subproblems. </span>

<span class="sd">We call :func:`benderAlgorithm()`, which is a function that implements the cycle.</span>
<span class="sd">Before doing that, we might apply some fixing schemes (both to zero and to one)</span>
<span class="sd">based on the LP relaxation. See functions :meth:`MIP.solveLPOne()` and</span>
<span class="sd">:meth:`MIP.solveLPZero()`.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">getopt</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">cplex</span>
<span class="kn">from</span> <span class="nn">cplex.callbacks</span> <span class="k">import</span> <span class="n">UserCutCallback</span><span class="p">,</span> <span class="n">LazyConstraintCallback</span>
<span class="kn">from</span> <span class="nn">cplex.callbacks</span> <span class="k">import</span> <span class="n">SolveCallback</span><span class="p">,</span> <span class="n">SimplexCallback</span>

<span class="kn">from</span> <span class="nn">cplex.exceptions</span> <span class="k">import</span> <span class="n">CplexError</span>

<span class="kn">from</span> <span class="nn">lagrange</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">dw2</span> <span class="k">import</span> <span class="o">*</span>
<span class="c1">#  from dw import *</span>


<span class="n">_INFTY</span>    <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span>
<span class="n">_EPSI</span>     <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span>
<span class="n">inputfile</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">userCuts</span>  <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
<span class="n">cPercent</span>  <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">algo</span>      <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1">#  we set the master variables as global, while the subproblem vars are local</span>
<span class="n">z_ilo</span>     <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">y_ilo</span>     <span class="o">=</span> <span class="p">[]</span>
<span class="n">lCapacity</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">lLogic</span>    <span class="o">=</span> <span class="p">[]</span>
<span class="n">lDemand</span>   <span class="o">=</span> <span class="p">[]</span>

<span class="n">inout</span>     <span class="o">=</span> <span class="p">[]</span>
<span class="n">yRef</span>      <span class="o">=</span> <span class="p">[]</span>
<span class="n">yPool</span>     <span class="o">=</span> <span class="p">[]</span>
<span class="n">nPool</span>     <span class="o">=</span> <span class="mi">0</span>
<span class="n">ubBest</span>    <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">startTime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<div class="viewcode-block" id="SolveNodeCallback"><a class="viewcode-back" href="../clspBenders.html#clspBenders.SolveNodeCallback">[docs]</a><span class="k">class</span> <span class="nc">SolveNodeCallback</span><span class="p">(</span><span class="n">SimplexCallback</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I AM here &quot;</span><span class="p">)</span>
        <span class="c1">#  self.solve()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OBJ &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RC&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reduced_costs</span><span class="p">())</span>
        <span class="nb">input</span><span class="p">(</span><span class="s2">&quot; ... &quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BendersLazyConsCallback"><a class="viewcode-back" href="../clspBenders.html#clspBenders.BendersLazyConsCallback">[docs]</a><span class="k">class</span> <span class="nc">BendersLazyConsCallback</span><span class="p">(</span><span class="n">LazyConstraintCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the LazyConstraintCallback of cplex. We implement Benders algorithm</span>
<span class="sd">    via callback. That it, the master is solved within a branch and bound</span>
<span class="sd">    framework and, every time a new master solution is obtained, the callback</span>
<span class="sd">    is used to:</span>

<span class="sd">    * get the master solution :math:`y`</span>
<span class="sd">    * pass it to the subproblem to obtain :math:`\phi(y)`</span>
<span class="sd">    * get the dual values and define Benders cut</span>
<span class="sd">    * add the cut to the master</span>
<span class="sd">    * give control back to cplex</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the actions to be carried out at every callback.</span>

<span class="sd">        Note that the ``separate`` function of the subproblem is called here.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get data structure (self is the master)</span>
        <span class="n">cpx</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker</span>
        <span class="n">y_ilo</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_ilo</span>
        <span class="n">z_ilo</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_ilo</span>
        <span class="n">inp</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inp</span>
        <span class="n">yFixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yFixed</span>

        <span class="c1">#  get current master solution</span>
        <span class="n">zHat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">)</span>
        <span class="n">ySol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">ySol</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="c1">#  flatten =  [item for sublist in ySol for item in sublist]</span>
        <span class="c1">#  benders cut separation</span>
        <span class="n">cutType</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cutType</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#  a = [float(worker.cutLhs.val[i]) for i in range(inp.nI*inp.nP)]</span>
            <span class="c1">#  lhsSum = sum([a[i]*flatten[i] for i in range(inp.nI*inp.nP)])</span>
            <span class="c1">#  print(&quot;LhsSum = &quot;, lhsSum , &quot; vs &quot;, worker.cutRhs)</span>
            <span class="c1">#  print(lhsSum &lt;= worker.cutRhs)</span>
            <span class="c1">#  violated = (lhsSum - worker.cutRhs) &gt; 0.1</span>
            <span class="c1">#  print(&quot; violated ? &quot;, violated)</span>
            <span class="n">violated</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">violated</span><span class="p">:</span>
            <span class="c1"># add Benders cut to the master</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="p">,</span>
                         <span class="n">sense</span>     <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
                         <span class="n">rhs</span>        <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">,</span>
                         <span class="n">use</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>


        <span class="n">zLP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_best_objective_value</span><span class="p">()</span>
        <span class="c1">#  print(&quot;here &quot;, zLP)</span>
        <span class="c1">#  input(&quot;...&quot;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solved</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cpxCloneLP</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
            <span class="n">cpxCloneLP</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpxCloneLP</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
            <span class="n">cpxCloneLP</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solved</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpxCloneLP</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_reduced_costs</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="c1">#  add cut here ??</span>

            <span class="c1">#  print(&quot;Before adding cut to master : &quot;, cpx.linear_constraints.get_num())</span>
            <span class="c1">#  cutType = worker.separate(inp, yRef, 0.0, y_ilo, z_ilo)</span>
            <span class="c1">#  print(worker.cutLhs, &quot; &lt;= &quot;, worker.cutRhs)</span>
            <span class="c1">#  if cutType &gt; 0:</span>
            <span class="c1">#</span>
            <span class="c1">#      self.add(constraint = worker.cutLhs,</span>
            <span class="c1">#               sense     = &quot;L&quot;,</span>
            <span class="c1">#               rhs        = worker.cutRhs,</span>
            <span class="c1">#               use        = 0)</span>
            <span class="c1">#</span>
            <span class="c1">#  print(&quot;Cut added to master : &quot;, cpx.linear_constraints.get_num())</span>
            <span class="c1">#  input(&quot;....&quot;)</span>


        <span class="c1">#  nRowsMaster = cpx.linear_constraints.get_num()</span>
        <span class="c1">#  nRows = cpxClone.linear_constraints.get_num()</span>
        <span class="c1">#  print(&quot; entering with &quot;, nRowsMaster, &quot; rows in master and &quot;, nRows, &quot;\</span>
        <span class="c1">#  rows in clone ... &quot;)</span>
        <span class="c1">#  if nRowsMaster &lt;= nRows:</span>
        <span class="c1">#      cpxClone.linear_constraints.add(lin_expr=[worker.cutLhs],</span>
        <span class="c1">#                                              senses  =[&quot;L&quot;],</span>
        <span class="c1">#                                              rhs     =[worker.cutRhs])</span>
        <span class="c1">#      return</span>
        <span class="c1">#</span>
        <span class="c1">#  index = [i for i in range(nRows, nRowsMaster)]</span>
        <span class="c1">#</span>
        <span class="c1">#  #  print(&quot;ROWS ARE = &quot;, cpx.linear_constraints.get_rows())</span>
        <span class="c1">#  #  print(&quot;rhs are  = &quot;, cpx.linear_constraints.get_rhs())</span>
        <span class="c1">#  allConstr = cpx.linear_constraints.get_rows(index)</span>
        <span class="c1">#  allRhs    = cpx.linear_constraints.get_rhs(index)</span>
        <span class="c1">#  for i,j in enumerate(allRhs):</span>
        <span class="c1">#      #  print(i,j, allConstr[i])</span>
        <span class="c1">#</span>
        <span class="c1">#      cpxClone.linear_constraints.add(lin_expr = [allConstr[i]],</span>
        <span class="c1">#                                      senses   = [&quot;L&quot;],</span>
        <span class="c1">#                                      rhs      = [j])</span>
        <span class="c1">#</span>
        <span class="c1">#  #  cpx.set_problem_type(cpx.problem_type.LP)</span>
        <span class="c1">#  #  cpx.solve()</span>
        <span class="c1">#  #  for j in range(inp.nI):</span>
        <span class="c1">#  #      rc = cpx.solution.get_reduced_costs(y_ilo[j])</span>
        <span class="c1">#  #      print(&quot;REAL RC = &quot;, rc)</span>
        <span class="c1">#</span>
        <span class="c1">#  #  solve Master LP</span>
        <span class="c1">#  cpxClone.solve()</span>
        <span class="c1">#  #  print(&quot;LP sol Master is &quot;, cpx.solution.get_objective_value())</span>
        <span class="c1">#  zClone = cpxClone.solution.get_objective_value()</span>
        <span class="c1">#  slack = cpxClone.solution.get_linear_slacks()</span>
        <span class="c1">#  remove = [i for i in range(nRows) if slack[i] &gt; _EPSI]</span>
        <span class="c1">#  print(&quot; ... due to SLACK, removing &quot;, len(remove), &quot; constraints.&quot;)</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>
        <span class="c1">#  zClone = cpxCloneLP.solution.get_objective_value()</span>
        <span class="c1">#  print(&quot;CLONE z = &quot;, zClone, &quot; vs UB = &quot;, ub)</span>
        <span class="c1">#  print(&quot;ubBes is &quot;, ubBest, &quot; vs ub = &quot;, ub)</span>
        <span class="c1">#  from here</span>
        <span class="n">fixInClone</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="c1">#  rc = cpxCloneLP.solution.get_reduced_costs(y_ilo[j])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="c1">#  if yFixed[j][t] == 0 and (zLP + rc[t]) &gt; ub:</span>
                <span class="k">if</span> <span class="n">yFixed</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">zLP</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">ubBest</span><span class="p">:</span>
                    <span class="n">yFixed</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; [&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nIter</span><span class="p">,</span><span class="s2">&quot;] ** ** ** ** fixing to zero &quot;</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
                    <span class="n">fixInClone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span><span class="n">val</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">]),</span>
                             <span class="n">sense</span> <span class="o">=</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span>
                             <span class="n">rhs</span>   <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="c1">#  cpxClone.variables.set_upper_bounds(y_ilo[j][t], 0.0)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nIter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yFixed</span> <span class="o">=</span> <span class="n">yFixed</span></div>


<div class="viewcode-block" id="BendersUserCutCallback"><a class="viewcode-back" href="../clspBenders.html#clspBenders.BendersUserCutCallback">[docs]</a><span class="k">class</span> <span class="nc">BendersUserCutCallback</span><span class="p">(</span><span class="n">UserCutCallback</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the actions to be carried out at every callback.</span>

<span class="sd">        Note that the ``separate`` function of the subproblem is called here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Skip the separation if not at the end of the cut loop</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SOL USER CUT &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_best_objective_value</span><span class="p">())</span>
        <span class="n">cpxClone</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cpxClone</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpxClone</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
        <span class="n">cpxClone</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SOL &quot;</span><span class="p">,</span> <span class="n">cpxClone</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">())</span>

        <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;....&quot;</span><span class="p">)</span>
        <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_after_cut_loop</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c1"># get data structure (self is the master)</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker</span>
        <span class="n">y_ilo</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_ilo</span>
        <span class="n">z_ilo</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_ilo</span>
        <span class="n">inp</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inp</span>

        <span class="c1">#  get current master solution</span>
        <span class="n">zHat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">)</span>
        <span class="n">ySol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">ySol</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="n">flatten</span> <span class="o">=</span>  <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">ySol</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
        <span class="c1">#  benders cut separation</span>
        <span class="n">cutType</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cutType</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
            <span class="n">lhsSum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">flatten</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LhsSum = &quot;</span><span class="p">,</span> <span class="n">lhsSum</span> <span class="p">,</span> <span class="s2">&quot; vs &quot;</span><span class="p">,</span> <span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">)</span>
            <span class="n">violated</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhsSum</span> <span class="o">-</span> <span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;VIOLATED = &quot;</span><span class="p">,</span> <span class="n">violated</span><span class="p">)</span>
            <span class="c1">#  if (lhsSum &gt; worker.cutRhs):</span>
            <span class="k">if</span> <span class="n">violated</span><span class="p">:</span>
                <span class="c1"># add Benders cut to the master</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cut</span>       <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="p">,</span>
                         <span class="n">sense</span>     <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
                         <span class="n">rhs</span>       <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">,</span>
                         <span class="n">use</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></div>




<div class="viewcode-block" id="parseCommandLine"><a class="viewcode-back" href="../clspBenders.html#clspBenders.parseCommandLine">[docs]</a><span class="k">def</span> <span class="nf">parseCommandLine</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. func:parseCommandLine()</span>

<span class="sd">    Parse command line. Options are:</span>

<span class="sd">    -h help         usage help</span>

<span class="sd">    -i inputfile    instance file name</span>

<span class="sd">    -u userCuts    activate user cuts (fractional values)</span>

<span class="sd">    -c cpercent     corridor width</span>

<span class="sd">    -z zeros        soft fixing to zero</span>
<span class="sd">    </span>
<span class="sd">    -o ones        soft fixing to one</span>

<span class="sd">    -a algorithm   type of algorithm used:</span>

<span class="sd">    With respect to the type of algorithms that can be used, we have:</span>

<span class="sd">        1.  Benders Decomposition</span>
<span class="sd">        2.  Lagrangean Relaxation</span>
<span class="sd">        3.  Dantzig-Wolfe</span>
<span class="sd">        4.  Cplex MIP solver</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">inputfile</span>
    <span class="k">global</span> <span class="n">userCuts</span>
    <span class="k">global</span> <span class="n">cPercent</span>
    <span class="k">global</span> <span class="n">cZero</span>
    <span class="k">global</span> <span class="n">cOne</span>
    <span class="k">global</span> <span class="n">algo</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">getopt</span><span class="o">.</span><span class="n">getopt</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="s2">&quot;hi:u:c:z:o:a:&quot;</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;help&quot;</span><span class="p">,</span><span class="s2">&quot;ifile=&quot;</span><span class="p">,</span><span class="s2">&quot;ucuts&quot;</span><span class="p">,</span><span class="s2">&quot;cpercent&quot;</span><span class="p">,</span><span class="s2">&quot;zeros&quot;</span><span class="p">,</span><span class="s2">&quot;ones&quot;</span><span class="p">,</span><span class="s2">&quot;algorithm&quot;</span><span class="p">])</span>
    <span class="k">except</span> <span class="n">getopt</span><span class="o">.</span><span class="n">GetoptError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Command Line Error. Usage : python cflp.py -i &lt;inputfile&gt; -u</span><span class="se">\</span>
<span class="s2">        &lt;usercuts&gt; -c &lt;corridor width&gt; -z &lt;fix to zero&gt; -o &lt;fix to one&gt; </span><span class="se">\</span>
<span class="s2">        -a &lt;algorithm BD, LR, DW, Cplex&gt;&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">opt</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-h&quot;</span><span class="p">,</span> <span class="s2">&quot;--help&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Usage : python cflp.py -i &lt;inputfile&gt; -u &lt;usercuts&gt; -c </span><span class="se">\</span>
<span class="s2">            &lt;corridor width&gt; -z &lt;fix to zero&gt; -o &lt;fix to one&gt; </span><span class="se">\</span>
<span class="s2">            -a &lt;algorithm - BD, LR, DW, Cplex&gt;&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-i&quot;</span><span class="p">,</span> <span class="s2">&quot;--ifile&quot;</span><span class="p">):</span>
            <span class="n">inputfile</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-u&quot;</span><span class="p">,</span> <span class="s2">&quot;--ucuts&quot;</span><span class="p">):</span>
            <span class="n">userCuts</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;--cpercent&quot;</span><span class="p">):</span>
            <span class="n">cPercent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-z&quot;</span><span class="p">,</span> <span class="s2">&quot;--zeros&quot;</span><span class="p">):</span>
            <span class="n">cZero</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--ones&quot;</span><span class="p">):</span>
            <span class="n">cOne</span>  <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-a&quot;</span><span class="p">,</span> <span class="s2">&quot;--algorithm&quot;</span><span class="p">):</span>
            <span class="n">algo</span>  <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Instance"><a class="viewcode-back" href="../clspBenders.html#clspBenders.Instance">[docs]</a><span class="k">class</span> <span class="nc">Instance</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used to read the instance from a disk file.</span>
<span class="sd">    Instances are obtained from Trigeiro. We also compute a tight value for the</span>
<span class="sd">    big M constant, as well as a cumulative demand value for t to T.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputfile</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">d</span>        <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">c</span>        <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">f</span>        <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">h</span>        <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">a</span>        <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">m</span>        <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">max_prod</span> <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">cap</span>      <span class="o">=</span> <span class="p">[]</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">dcum</span>     <span class="o">=</span> <span class="p">[]</span>
       <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inputfile</span><span class="p">)</span> <span class="k">as</span> <span class="n">ff</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nI</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nP</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nr. items and nr. periods = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nI</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cap</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="c1">#  a = temp[0]*self.nP;</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span>
                <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>


       <span class="c1">#  compute cumulative demand</span>
       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
           <span class="n">aux</span> <span class="o">=</span> <span class="p">[]</span>
           <span class="n">aux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
           <span class="n">progr</span> <span class="o">=</span> <span class="mi">0</span>
           <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
               <span class="n">aux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
               <span class="n">progr</span> <span class="o">+=</span> <span class="mi">1</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">dcum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">aux</span><span class="p">)))</span>


       <span class="c1"># max production of item j in period t is the minimum between</span>
       <span class="c1"># the limit set by capacity and the cumulative demand</span>
       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
           <span class="n">aa</span> <span class="o">=</span> <span class="p">[(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">max_prod</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">aa</span><span class="p">[</span><span class="n">t</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dcum</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> \
           <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nP</span><span class="p">)])</span></div>


<div class="viewcode-block" id="MIP"><a class="viewcode-back" href="../clspBenders.html#clspBenders.MIP">[docs]</a><span class="k">class</span> <span class="nc">MIP</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. class:MIP()</span>

<span class="sd">    Define the full model and solve it using cplex. We use this class to</span>
<span class="sd">    compute optimal values of the full MIP models and compare them, along with</span>
<span class="sd">    the achieve performance, with the Benders approach.</span>

<span class="sd">    This is the Standard Lot Sizing implementation, using variables</span>
<span class="sd">    :math:`y_{jt}, x_{jt}, s_{jt}`. This formulation is no longer used in the</span>
<span class="sd">    current version of the code, since the SPL reformulation provides tighter</span>
<span class="sd">    relaxations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="n">y_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sI</span>    <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">sense</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>

        <span class="c1">#  create variables y_jt</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">y_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;x.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="c1">#  create variables x_jt</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">x_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;x.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                  <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>
        <span class="c1">#  create variables s_jt</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">s_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;s.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                  <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="c1">#  initial inventory level (avoid infeasibility)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;sI.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">sI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="mi">100000</span><span class="p">],</span>
                              <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                              <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                              <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">],</span>
                              <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="c1">#  demand constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="c1">#  first period</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sI</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span>
            <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="c1">#  periods 2 to T-1</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span>
                <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]])</span>

            <span class="c1">#  last period</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
            <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1">#  capacity constraints</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
            <span class="n">capacity_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">capacity_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span>

        <span class="c1">#  logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                <span class="n">logic_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span> <span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">logic_constraint</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>   <span class="o">=</span> <span class="n">cpx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_ilo</span> <span class="o">=</span> <span class="n">y_ilo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_ilo</span> <span class="o">=</span> <span class="n">x_ilo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ilo</span> <span class="o">=</span> <span class="n">s_ilo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sI</span>    <span class="o">=</span> <span class="n">sI</span>

<div class="viewcode-block" id="MIP.solveLPZero"><a class="viewcode-back" href="../clspBenders.html#clspBenders.MIP.solveLPZero">[docs]</a>    <span class="k">def</span> <span class="nf">solveLPZero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. method:solveLPZero()</span>

<span class="sd">        Solve LP relaxation of original MIP twice:</span>
<span class="sd">        </span>
<span class="sd">        - the first time, we solve the LP relaxation of the whole problem, and</span>
<span class="sd">          we store the variables whose value is zero in the LP solution</span>
<span class="sd">          (indexLP1)</span>
<span class="sd">        - the second time, we add a &quot;corridor&quot; type of constraint to the LP,</span>
<span class="sd">          enforcing that at least a given number of variables in indexLP1 will</span>
<span class="sd">          change value, i.e., will take a value above 0. We store in indexLP2</span>
<span class="sd">          the variables that take value zero in the LP-constrained model.</span>
<span class="sd">        - the intersection between indexLP1 and indexLP2 gives the set of</span>
<span class="sd">          variables we want to keep fixed to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">y_ilo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_ilo</span>

        <span class="c1">#  transform MIP into LP and solve it</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">yLP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">yLP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="c1">#  add &quot;corridor&quot; constraint (and solve LP again)</span>
        <span class="n">indexLP1</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span> <span class="k">if</span>
        <span class="n">yLP</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">_EPSI</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">indexLP1</span><span class="p">)</span>
        <span class="n">rhsVal</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">indexLP1</span><span class="p">)</span> <span class="c1">#  change at least rhsVal variables</span>
        <span class="n">zero_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">indexLP1</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span>  <span class="o">=</span> <span class="p">[</span><span class="n">zero_constraint</span><span class="p">],</span>
                                   <span class="n">senses</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">],</span>
                                   <span class="n">rhs</span>       <span class="o">=</span> <span class="p">[</span><span class="n">rhsVal</span><span class="p">],</span>
                                   <span class="n">names</span>     <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fixLP&quot;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="c1">#  solve LP-constrained version</span>
        <span class="n">yLP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">yLP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
        <span class="n">indexLP2</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span> <span class="k">if</span>
        <span class="n">yLP</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">_EPSI</span><span class="p">]</span>
        <span class="c1">#  fix to zero vars that are at zero in both LPs</span>
        <span class="n">fixToZero</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexLP1</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">indexLP2</span><span class="p">))</span>
        <span class="c1">#  print(&quot;INTERSECTION = &quot;, fixToZero)</span>

        <span class="c1">#  restore MIP</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">MILP</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_types</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">binary</span><span class="p">)</span>

        <span class="c1">#  remove the corridor constraint from the main model</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s2">&quot;fixLP&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fixToZero</span></div>


<div class="viewcode-block" id="MIP.solveLPOne"><a class="viewcode-back" href="../clspBenders.html#clspBenders.MIP.solveLPOne">[docs]</a>    <span class="k">def</span> <span class="nf">solveLPOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. method:solveLPOne()</span>

<span class="sd">        Same idea presented in :func:`solveLPZero()`. See comment above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">y_ilo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_ilo</span>

        <span class="c1">#  transform into LP and solve it</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">yLP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">yLP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="c1">#  add &quot;corridor&quot; contraint</span>
        <span class="n">indexLP1</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span> <span class="k">if</span>
        <span class="n">yLP</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span><span class="n">_EPSI</span><span class="p">)]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">indexLP1</span><span class="p">)</span>
        <span class="n">rhsVal</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="mf">0.25</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">indexLP1</span><span class="p">)</span>
        <span class="n">zero_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">indexLP1</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span>  <span class="o">=</span> <span class="p">[</span><span class="n">zero_constraint</span><span class="p">],</span>
                                   <span class="n">senses</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                   <span class="n">rhs</span>       <span class="o">=</span> <span class="p">[</span><span class="n">rhsVal</span><span class="p">],</span>
                                   <span class="n">names</span>     <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fixLP&quot;</span><span class="p">])</span>

        <span class="c1">#  solve constrained version of LP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">yLP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">yLP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="n">indexLP2</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span> <span class="k">if</span>
        <span class="n">yLP</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">_EPSI</span><span class="p">)]</span>

        <span class="c1">#  get interception between indexLP1 and indexLP2</span>
        <span class="n">fixToOne</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexLP1</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">indexLP2</span><span class="p">))</span>
        <span class="c1">#  print(&quot;INTERSECTION = &quot;, fixToOne)</span>

        <span class="c1">#  restore original MIP</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">MILP</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_types</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">binary</span><span class="p">)</span>

        <span class="c1">#  eliminate corridor constraint</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s2">&quot;fixLP&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fixToOne</span></div>

<div class="viewcode-block" id="MIP.solve"><a class="viewcode-back" href="../clspBenders.html#clspBenders.MIP.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">nSol</span><span class="o">=</span><span class="mi">99999</span><span class="p">,</span> <span class="n">withPool</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">withPrinting</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">timeLimit</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. method:solve()</span>

<span class="sd">        Solve the original MIMPLS using cplex branch and bound. A number of</span>
<span class="sd">        flags can be activate, to control the behavior of the solver:</span>

<span class="sd">        * nSol : maximum number of solutions to be visited</span>
<span class="sd">        * withPool : collect a pool of solutions during the optimization phase</span>
<span class="sd">        * withPrinting: control the output</span>
<span class="sd">        * display : control cplex output</span>
<span class="sd">        * timeLimit : set a maximum time limit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">yRef</span>
        <span class="k">global</span> <span class="n">ubBest</span>
        <span class="k">global</span> <span class="n">yPool</span>
        <span class="k">global</span> <span class="n">nPool</span>

        <span class="n">y_ilo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_ilo</span>
        <span class="n">z_ilo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_ilo</span>
        <span class="n">cpx</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>

        <span class="c1">#  cpx.set_results_stream(None)</span>
        <span class="c1">#  cpx.set_log_stream(None)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">timelimit</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">timeLimit</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mip</span><span class="o">.</span><span class="n">limits</span><span class="o">.</span><span class="n">solutions</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">nSol</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mip</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
        <span class="c1">#  cpx.parameters.mip.interval.set(500) # how often to print info</span>
        <span class="c1">#  cpx.parameters.mip.tolerances.mipgap.set(0.000000001)</span>
        <span class="c1">#  cpx.parameters.mip.tolerances.absmipgap.set(0.000000001)</span>


        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">withPrinting</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STATUS = &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">status</span><span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_status</span><span class="p">()])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OPT SOL found = &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">())</span>
        <span class="c1">#  if cpx.solution.get_status() == cpx.solution.status.optimal_tolerance\</span>
            <span class="c1">#  or cpx.solution.get_status() == cpx.solution.status.optimal:</span>
        <span class="n">ubBest</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">withPrinting</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="n">yRef</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;y(&quot;</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s2">&quot;) = &quot;</span><span class="p">,</span> <span class="n">yRef</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   z(&quot;</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot;) = &quot;</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span>
                    <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">withPool</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">get_names</span><span class="p">()</span>
            <span class="n">nPool</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;z(&quot;</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="s2">&quot;) = &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

                <span class="n">yAux</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                    <span class="n">yAux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">yPool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yAux</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ubBest</span></div></div>



<div class="viewcode-block" id="MIPReformulation"><a class="viewcode-back" href="../clspBenders.html#clspBenders.MIPReformulation">[docs]</a><span class="k">class</span> <span class="nc">MIPReformulation</span><span class="p">(</span><span class="n">MIP</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. class:MIPReformulation()</span>

<span class="sd">    This class implements the SPL reformulation, which is the one currently</span>
<span class="sd">    used in the code. The reformulation has been presented in the introduction</span>
<span class="sd">    of this code and makes use of two sets of variables, i.e.:</span>

<span class="sd">    * :math:`y_{jt}` : setup variables</span>
<span class="sd">    * :math:`z_{jtr}`: production variables, indicating the amount of production of item *j* produced in period *t* to satisfy the demand of period *r*. Obviously, :math:`z_{jtr} = 0` for all *t&gt;r*.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="n">y_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z_ilo</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">sense</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>
        <span class="c1">#  cpx.set_results_stream(None)</span>
        <span class="c1">#  cpx.set_log_stream(None)</span>

        <span class="c1">#  create variables y_jt</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">y_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;y.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>
        <span class="c1">#  create variables z_jts</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">z_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;z.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                      <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                      <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                      <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">],</span>
                                      <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="c1">#  demand constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]])</span>

        <span class="c1">#  capacity constraint</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span><span class="o">*</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
            <span class="n">capacity_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span>  <span class="o">=</span> <span class="p">[</span><span class="n">capacity_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>       <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span>

        <span class="c1">#  logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span>
                    <span class="n">logic_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span> <span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">logic_constraint</span><span class="p">],</span>
                                               <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                               <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">])</span>
        <span class="c1">#  cumulative logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="p">[</span><span class="o">-</span><span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                <span class="n">logic_constraint_cum</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span> <span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">logic_constraint_cum</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">])</span>


        <span class="c1">#  set to zero unused variables</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_upper_bounds</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>   <span class="o">=</span> <span class="n">cpx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_ilo</span> <span class="o">=</span> <span class="n">y_ilo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_ilo</span> <span class="o">=</span> <span class="n">z_ilo</span></div>


<div class="viewcode-block" id="WorkerLP"><a class="viewcode-back" href="../clspBenders.html#clspBenders.WorkerLP">[docs]</a><span class="k">class</span> <span class="nc">WorkerLP</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. class:WorkerLP()</span>

<span class="sd">    Define and solve the subproblem. We initilize the subproblem with the right</span>
<span class="sd">    hand side values of the constraints to zero, since we assume the initial</span>
<span class="sd">    values of :math:`y_{jt}` to be equal to zero. Next, within the</span>
<span class="sd">    :meth:`WorkerLP.separate()` function, we define the rhs values to the </span>
<span class="sd">    correct values, depending on the solution obtained from the master.</span>

<span class="sd">    Cplex requires the presolve reductions to be turned off, using::</span>

<span class="sd">        cpx.parameters.preprocessing.reduce.set(0)</span>

<span class="sd">    In addition, we need to ensure that the LP is *not* solved using the</span>
<span class="sd">    interior point method, otherwise dual values won&#39;t be available. We can</span>
<span class="sd">    either use primal simplex or dual simplex.</span>

<span class="sd">    .. note ::</span>

<span class="sd">        The subproblem constraints should be defined with a name, in</span>
<span class="sd">        order to be able to recall the precise name of each constraint when we </span>
<span class="sd">        want to obtain the dual values. Briefly, we need to:</span>

<span class="sd">        * define a unique name for each constraint, e.g., ``capacity.t`` for each t</span>
<span class="sd">        * store such names in a vector of names, e.g,::</span>

<span class="sd">            lCapacity = [&quot;capacity.&quot; + str(t) for t in range(inp.nP)]</span>

<span class="sd">        * get the dual values using::</span>

<span class="sd">           dCapacity = cpx.solution.get_dual_values(lCapacity)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>

        <span class="n">x_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sI</span>    <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_results_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_log_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


        <span class="c1"># Turn off the presolve reductions and set the CPLEX optimizer</span>
        <span class="c1"># to solve the worker LP with primal simplex method.</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">off</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">reduce</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#  cpx.parameters.lpmethod.set(cpx.parameters.lpmethod.values.primal)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">lpmethod</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">lpmethod</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dual</span><span class="p">)</span>

        <span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">sense</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">x_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;x.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                  <span class="c1">#  types = [&quot;C&quot;],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">s_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;s.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                  <span class="c1">#  types = [&quot;C&quot;],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>


        <span class="c1">#  this variables are used to allow for unlimited initial inventory</span>
        <span class="c1">#  for j in range(inp.nI):</span>
        <span class="c1">#      varName = &quot;sI.&quot; + str(j)</span>
        <span class="c1">#      sI.append(cpx.variables.get_num())</span>
        <span class="c1">#      cpx.variables.add(obj   = [1000],</span>
        <span class="c1">#                        lb    = [0.0],</span>
        <span class="c1">#                        ub    = [cplex.infinity],</span>
        <span class="c1">#                        #  ub    = [0.0],</span>
        <span class="c1">#                        #  types = [&quot;C&quot;],</span>
        <span class="c1">#                        names = [varName])</span>

        <span class="c1">#  capacity constraints</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>

            <span class="n">capacity_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;capacity.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">capacity_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                       <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>
        <span class="c1">#  demand constraints</span>
        <span class="c1">#  note: If we want to include unlimited initial inventory, change this</span>
        <span class="c1">#  constraint, including sI</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="c1">#  first period</span>
            <span class="c1">#  index = [x_ilo[j][0], sI[j], s_ilo[j][0]]</span>
            <span class="c1">#  value = [1.0, 1.0, -1.0]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span>
<span class="c1">#</span>
            <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;demand.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.0&quot;</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                                       <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>
            <span class="c1">#  periods 2 to T-1</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span>
                <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;demand.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                           <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>

            <span class="c1">#  last period</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
            <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;demand.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                                       <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>


        <span class="c1">#  logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;logic.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">logic_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                                    <span class="n">val</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">logic_constraint</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                           <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>


        <span class="c1"># define labels for constraints</span>
        <span class="n">lCapacity</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;capacity.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">lLogic</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;logic.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">lDemand</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;demand.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>       <span class="o">=</span> <span class="n">cpx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_ilo</span>     <span class="o">=</span> <span class="n">x_ilo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ilo</span>     <span class="o">=</span> <span class="n">s_ilo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sI</span>        <span class="o">=</span> <span class="n">sI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lCapacity</span> <span class="o">=</span> <span class="n">lCapacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lLogic</span>    <span class="o">=</span> <span class="n">lLogic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lDemand</span>   <span class="o">=</span> <span class="n">lDemand</span>

<div class="viewcode-block" id="WorkerLP.separate"><a class="viewcode-back" href="../clspBenders.html#clspBenders.WorkerLP.separate">[docs]</a>    <span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. method:separate()</span>

<span class="sd">        This is the *old* implementation, based on the standard Lot Sizing</span>
<span class="sd">        formulation. Here is were Benders cut is obtained and passed to the master.</span>

<span class="sd">        The following steps describe the algorithm:</span>

<span class="sd">        * update rhs values of the subproblem, i.e., using the current optimal solution of the master problem :math:`y^*`</span>
<span class="sd">        * solve the subproblem</span>
<span class="sd">        * get the dual values :math:`\lambda, \\nu`</span>
<span class="sd">        * generate cut (lhs and rhs) and store them in a constraint structure</span>
<span class="sd">        * pass the cut to the master</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cutType</span>   <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cpx</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">x_ilo</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_ilo</span>
        <span class="n">s_ilo</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_ilo</span>
        <span class="n">sI</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sI</span>
        <span class="n">lCapacity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lCapacity</span>
        <span class="n">lLogic</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lLogic</span>
        <span class="n">lDemand</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lDemand</span>

        <span class="c1">#  update rhs values : logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;logic.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="c1">#  if ySol[j][t] &gt;= (1.0-_EPSI):</span>
                <span class="n">rhsValue</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
                <span class="c1">#  else:</span>
                    <span class="c1">#  rhsValue = 0.0</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">set_rhs</span><span class="p">(</span><span class="n">constrName</span><span class="p">,</span> <span class="n">rhsValue</span><span class="p">)</span>

        <span class="c1">#  update rhs values : capacity constraints</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">sumY</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)])</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;capacity.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">set_rhs</span><span class="p">(</span><span class="n">constrName</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">-</span><span class="n">sumY</span><span class="p">)</span>

        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>


        <span class="c1">#  print(&quot;STATUS = &quot;, cpx.solution.status[cpx.solution.get_status()])</span>
        <span class="c1">#  print(&quot;z_sub  = &quot;, cpx.solution.get_objective_value())</span>
        <span class="c1">#  xSol = cpx.solution.get_values(x_ilo)</span>
        <span class="c1">#  sISol = cpx.solution.get_values(sI)</span>
        <span class="c1">#  print(&quot;X : &quot;, xSol)</span>
        <span class="c1">#  print(&quot;SI : &quot;, sISol)</span>
        <span class="c1">#  vars and values for the cut lhs</span>
        <span class="n">cutVars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cutVals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">zSub</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span> <span class="o">==</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">infeasible</span><span class="p">:</span>
            <span class="n">cutType</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1">#  add extreme ray</span>
            <span class="c1">#  cpx.solution.advanced.get_ray()</span>
            <span class="c1">#  note: we cannot get the rays without explicitly formulating the</span>
            <span class="c1">#  dual. We use Farkas certificate</span>
            <span class="n">farkas</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">advanced</span><span class="o">.</span><span class="n">dual_farkas</span><span class="p">()</span>
            <span class="c1">#  print(&quot;Farkas are : &quot;, farkas, &quot; ** &quot;, pp)</span>
            <span class="n">progr</span>     <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span>
            <span class="n">index</span>     <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">progr</span><span class="p">)</span>
            <span class="n">fCapacity</span> <span class="o">=</span> <span class="p">[</span><span class="n">farkas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
            <span class="n">index</span>     <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">progr</span><span class="p">,</span><span class="n">progr</span><span class="o">+</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
            <span class="n">fDemand</span>   <span class="o">=</span> <span class="p">[</span><span class="n">farkas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
            <span class="n">progr</span>    <span class="o">+=</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span>
            <span class="n">index</span>     <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">progr</span><span class="p">,</span> <span class="n">progr</span><span class="o">+</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
            <span class="n">fLogic</span>    <span class="o">=</span> <span class="p">[</span><span class="n">farkas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>

            <span class="c1">#  rhsConstr = cpx.linear_constraints.get_rhs()</span>
            <span class="c1">#  progr = 0</span>
            <span class="c1">#  for i in enumerate(rhsConstr):</span>
            <span class="c1">#      print(&quot;i is &quot;, i, &quot; with farkas = &quot;, farkas[progr])</span>
            <span class="c1">#      progr += 1</span>

            <span class="c1">#  feasibility cut</span>
            <span class="n">cutRhs</span>  <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">progr</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span> <span class="o">+</span> <span class="n">t</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fLogic</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span> <span class="o">-</span> \
                    <span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fCapacity</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

                    <span class="n">cutVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
                    <span class="n">cutVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                    <span class="n">cutRhs</span> <span class="o">-=</span> <span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fDemand</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">cutRhs</span> <span class="o">-=</span> <span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fCapacity</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span> <span class="o">==</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">optimal</span><span class="p">:</span>
            <span class="n">cutType</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">zSub</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>
            <span class="c1">#  the solution is feasible (it will always be, due to vars sI)</span>
            <span class="n">dCapacity</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lCapacity</span><span class="p">)</span>
            <span class="n">dLogic</span>    <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lLogic</span><span class="p">)</span>
            <span class="n">dDemand</span>   <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lDemand</span><span class="p">)</span>


            <span class="c1">#  method 1: generalized benders</span>
            <span class="n">cutRhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">zSub</span>
            <span class="n">progr</span>  <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">dCapacity</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span>\
                    <span class="n">dLogic</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>

                    <span class="n">cutVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
                    <span class="n">cutVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

                    <span class="n">cutRhs</span> <span class="o">+=</span> <span class="n">coeff</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
                    <span class="n">progr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">cutVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">)</span>
            <span class="n">cutVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>


            <span class="c1"># method 2: the &quot;standard&quot; benders</span>
            <span class="c1">#  cutRhs = 0.0</span>
            <span class="c1">#  progr  = 0</span>
            <span class="c1">#  for j in range(inp.nI):</span>
            <span class="c1">#      for t in range(inp.nP):</span>
            <span class="c1">#          coeff = inp.max_prod[j][t]*dLogic[progr] - \</span>
            <span class="c1">#          inp.m[j][t]*dCapacity[t]</span>
            <span class="c1">#</span>
            <span class="c1">#          cutVars.append(y_ilo[j][t])</span>
            <span class="c1">#          cutVals.append(coeff)</span>
            <span class="c1">#</span>
            <span class="c1">#          cutRhs -= inp.d[j][t]*dDemand[progr]</span>
            <span class="c1">#</span>
            <span class="c1">#          progr += 1</span>
            <span class="c1">#</span>
            <span class="c1">#  cutVars.append(z_ilo)</span>
            <span class="c1">#  cutVals.append(-1.0)</span>
            <span class="c1">#  for t in range(inp.nP):</span>
            <span class="c1">#      cutRhs -= inp.cap[t]*dCapacity[t]</span>


        <span class="c1">#  return cut and type</span>
        <span class="n">cutLhs</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">cutVars</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">cutVals</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutLhs</span> <span class="o">=</span> <span class="n">cutLhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutRhs</span> <span class="o">=</span> <span class="n">cutRhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zSub</span>   <span class="o">=</span> <span class="n">zSub</span>

        <span class="k">return</span> <span class="n">cutType</span></div></div>


<div class="viewcode-block" id="WorkerLPReformulation"><a class="viewcode-back" href="../clspBenders.html#clspBenders.WorkerLPReformulation">[docs]</a><span class="k">class</span> <span class="nc">WorkerLPReformulation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. class:WorkerLPReformulation()</span>

<span class="sd">        Formulation of the subproblem (the worker) using the SPL reformulation.</span>
<span class="sd">        This is what is currently used in Benders&#39; algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        **Note**: The rhs value of both the logic constraints and the capacity</span>
<span class="sd">        constraints, as well as the cumulative capacity constraints, will be</span>
<span class="sd">        update during the separation phase, implemented in</span>
<span class="sd">        :meth:`WorkerLPReformulation.separate()`, since the value of variables</span>
<span class="sd">        :math:`y_{jt}` will be provided by the master. Here we thus initialize</span>
<span class="sd">        these rhs values to either 0 or a convenient value.</span>

<span class="sd">        Note the use of labels for constraints. These labels are needed to</span>
<span class="sd">        access the dual values of those constraints in the separation phase.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">z_ilo</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_results_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_log_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Turn off the presolve reductions and set the CPLEX optimizer</span>
        <span class="c1"># to solve the worker LP with primal simplex method.</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">off</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">reduce</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#  cpx.parameters.lpmethod.set(cpx.parameters.lpmethod.values.primal)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">lpmethod</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">lpmethod</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dual</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">sense</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>

        <span class="c1">#  create variables z_jts</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">z_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;z.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                      <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                      <span class="c1">#  ub    = [cplex.infinity],</span>
                                      <span class="c1">#  ub    = [inp.d[j][r]],</span>
                                      <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>


        <span class="c1">#  capacity constraint</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]]</span><span class="o">*</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;capacity.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">capacity_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span>  <span class="o">=</span> <span class="p">[</span><span class="n">capacity_constraint</span><span class="p">],</span>
                                       <span class="n">senses</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>       <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]],</span>
                                       <span class="n">names</span>     <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>

        <span class="c1">#  demand constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;demand.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">demand_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_constraint</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]],</span>
                                           <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>
        <span class="c1">#  logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
                    <span class="n">logic_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span> <span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;logic.&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">logic_constraint</span><span class="p">],</span>
                                               <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                               <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                               <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>

        <span class="c1">#  cumulative logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
                <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;cumLogic.&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">logic_constraint_cum</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span> <span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">logic_constraint_cum</span><span class="p">],</span>
                                           <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                           <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                           <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>


        <span class="c1">#  set to zero unused variables</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_upper_bounds</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>


        <span class="c1">#  for j in range(inp.nI):</span>
            <span class="c1">#  for r in range(inp.nP):</span>
                <span class="c1">#  for t in range(r):</span>
                    <span class="c1">#  cpx.variables.set_upper_bounds(z_ilo[j][t][r], inp.d[j][r])</span>

        <span class="c1"># define labels for constraints (used in separation to get dual values)</span>
        <span class="n">lCapacity</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;capacity.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">lDemand</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;demand.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">lLogic</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;logic.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> \
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">lcumLogic</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cumLogic.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>       <span class="o">=</span> <span class="n">cpx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_ilo</span>     <span class="o">=</span> <span class="n">z_ilo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lCapacity</span> <span class="o">=</span> <span class="n">lCapacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lDemand</span>   <span class="o">=</span> <span class="n">lDemand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lLogic</span>    <span class="o">=</span> <span class="n">lLogic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lcumLogic</span> <span class="o">=</span> <span class="n">lcumLogic</span>

<div class="viewcode-block" id="WorkerLPReformulation.formulateDual"><a class="viewcode-back" href="../clspBenders.html#clspBenders.WorkerLPReformulation.formulateDual">[docs]</a>    <span class="k">def</span> <span class="nf">formulateDual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">w_ilo</span><span class="p">,</span> <span class="n">l_ilo</span><span class="p">,</span> <span class="n">v_ilo</span><span class="p">,</span> <span class="n">e_ilo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formulation of the subproblem dual. This is no longer used, but I leave</span>
<span class="sd">        it here for the sake of completeness. I checked that the formulation is</span>
<span class="sd">        correct, since the objective function value of the optimal dual is</span>
<span class="sd">        identical to that of the optimal primal.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">w_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">w_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;w.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">l_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
            <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;l.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="n">coeff</span> <span class="o">-=</span> <span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">coeff</span><span class="p">],</span>
                              <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                              <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                              <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">v_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">v_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;v.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                  <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                  <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                  <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">e_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">e_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">e_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
                    <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;e.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>    <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                      <span class="n">lb</span>     <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                                      <span class="n">ub</span>     <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                                      <span class="n">names</span>  <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_upper_bounds</span><span class="p">(</span><span class="n">e_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">],</span><span class="mf">0.0</span><span class="p">)</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_lower_bounds</span><span class="p">(</span><span class="n">e_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">],</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">sense</span><span class="o">.</span><span class="n">maximize</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;dual.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">w_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="n">l_ilo</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">v_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">e_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
                    <span class="n">dual_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">dual_constraint</span><span class="p">],</span>
                                               <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                               <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                                               <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span></div>

<div class="viewcode-block" id="WorkerLPReformulation.paretoOptimal"><a class="viewcode-back" href="../clspBenders.html#clspBenders.WorkerLPReformulation.paretoOptimal">[docs]</a>    <span class="k">def</span> <span class="nf">paretoOptimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">zDual</span><span class="p">,</span> <span class="n">zHat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get pareto optimal cuts. See paper for an explanation. In principle,</span>
<span class="sd">        this should be helpful, since the dual problem is degenerate and,</span>
<span class="sd">        consequently, multiple optimal solutions should exist. This means that</span>
<span class="sd">        the &quot;right&quot; selection of dual values should make a difference in the</span>
<span class="sd">        strength of the cut. However, the extra effort required to get pareto</span>
<span class="sd">        optimal cuts does not seem to be compensated by the minor improvement</span>
<span class="sd">        obtained here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>

        <span class="n">cpx</span><span class="o">.</span><span class="n">set_results_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_log_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
        <span class="c1">#  y0 = yRef</span>
        <span class="c1">#  y0 = ySol</span>
        <span class="n">w_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">l_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">v_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">e_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formulateDual</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">w_ilo</span><span class="p">,</span> <span class="n">l_ilo</span><span class="p">,</span> <span class="n">v_ilo</span><span class="p">,</span> <span class="n">e_ilo</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">w_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">l_ilo</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="n">aux</span> <span class="o">-=</span> <span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">+=</span> <span class="n">coeffs</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span>
                    <span class="n">value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span>

        <span class="n">index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>

        <span class="n">obj_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span>  <span class="o">=</span> <span class="p">[</span><span class="n">obj_constraint</span><span class="p">],</span>
                                   <span class="n">senses</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span>
                                   <span class="n">rhs</span>       <span class="o">=</span> <span class="p">[</span><span class="n">zDual</span><span class="p">],</span>
                                   <span class="n">names</span>     <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;obj_constraint&quot;</span><span class="p">])</span>


        <span class="c1">#  cpx.write(&quot;pareto.lp&quot;)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="n">dDemand</span> <span class="o">=</span> <span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">w_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">dCapacity</span> <span class="o">=</span> <span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">l_ilo</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">dcumLogic</span> <span class="o">=</span> <span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">v_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">dLogic</span> <span class="o">=</span> <span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">e_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span>
        <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        
        <span class="k">return</span> <span class="n">dDemand</span><span class="p">,</span> <span class="n">dCapacity</span><span class="p">,</span> <span class="n">dcumLogic</span><span class="p">,</span> <span class="n">dLogic</span></div>

<div class="viewcode-block" id="WorkerLPReformulation.solveDual"><a class="viewcode-back" href="../clspBenders.html#clspBenders.WorkerLPReformulation.solveDual">[docs]</a>    <span class="k">def</span> <span class="nf">solveDual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">zHat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the dual problem (i.e., an explicit way of obtained the dual</span>
<span class="sd">        values needed to create the optimality cut. It is no longer used.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_results_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_log_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">w_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">l_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">v_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">e_ilo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formulateDual</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">w_ilo</span><span class="p">,</span> <span class="n">l_ilo</span><span class="p">,</span> <span class="n">v_ilo</span><span class="p">,</span> <span class="n">e_ilo</span><span class="p">)</span>

        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">zDual</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>

        <span class="n">dDemand</span><span class="p">,</span> <span class="n">dCapacity</span><span class="p">,</span> <span class="n">dcumLogic</span><span class="p">,</span> <span class="n">dLogic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paretoOptimal</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span>
        <span class="n">zDual</span><span class="p">,</span> <span class="n">zHat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dDemand</span><span class="p">,</span> <span class="n">dCapacity</span><span class="p">,</span> <span class="n">dcumLogic</span><span class="p">,</span> <span class="n">dLogic</span></div>



<div class="viewcode-block" id="WorkerLPReformulation.separate"><a class="viewcode-back" href="../clspBenders.html#clspBenders.WorkerLPReformulation.separate">[docs]</a>    <span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo_m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. method:separate()</span>

<span class="sd">        This is the separation scheme for the WorkerLPReformulation, i.e., the</span>
<span class="sd">        SPL reformulation. Here is were Benders cut is obtained and passed to </span>
<span class="sd">        the master.</span>

<span class="sd">        The following steps describe the algorithm:</span>

<span class="sd">        * update rhs values of the subproblem, i.e., using the current optimal solution of the master problem :math:`y^*`</span>
<span class="sd">        * solve the subproblem</span>
<span class="sd">        * get the dual values :math:`\lambda, \\nu`</span>
<span class="sd">        * generate cut (lhs and rhs) and store them in a constraint structure</span>
<span class="sd">        * pass the cut to the master</span>

<span class="sd">        Advanced cplex functions are used here, e.g.::</span>
<span class="sd">        </span>
<span class="sd">            farkas, pp = cpx.solution.advanced.dual_farkas()</span>

<span class="sd">        to get Farkas certificates used to get the extreme rays, and::</span>

<span class="sd">            dCapacity = cpx.solution.get_dual_values(lCapacity)</span>

<span class="sd">        to get the dual values, which are used in the creation of optimality</span>
<span class="sd">        cuts. </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cutType</span>   <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cpx</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">z_ilo</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_ilo</span>
        <span class="n">lCapacity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lCapacity</span>
        <span class="n">lDemand</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lDemand</span>
        <span class="n">lLogic</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lLogic</span>
        <span class="n">lcumLogic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lcumLogic</span>

        <span class="n">cpx</span><span class="o">.</span><span class="n">set_results_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">set_log_stream</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1">#  update rhs values : logic constraints</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;logic.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">rhsValue</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">set_rhs</span><span class="p">(</span><span class="n">constrName</span><span class="p">,</span> <span class="n">rhsValue</span><span class="p">)</span>

        <span class="c1">#  update rhs values : capacity constraints</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">sumY</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)])</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;capacity.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">set_rhs</span><span class="p">(</span><span class="n">constrName</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">-</span><span class="n">sumY</span><span class="p">)</span>

        <span class="c1">#  update cumulative capacity</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;cumLogic.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">rhsValue</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">set_rhs</span><span class="p">(</span><span class="n">constrName</span><span class="p">,</span> <span class="n">rhsValue</span><span class="p">)</span>


        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">zSub</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>


        <span class="c1">#  print(&quot;STATUS = &quot;, cpx.solution.status[cpx.solution.get_status()])</span>
        <span class="c1">#  print(&quot;z_sub  = &quot;, cpx.solution.get_objective_value())</span>
        <span class="c1">#  vars and values for the cut lhs</span>
        <span class="n">cutVars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cutVals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span> <span class="o">==</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">infeasible</span><span class="p">:</span>
            <span class="n">cutType</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1">#  add extreme ray using Farkas certificate</span>
            <span class="n">farkas</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">advanced</span><span class="o">.</span><span class="n">dual_farkas</span><span class="p">()</span>
            <span class="c1">#  print(&quot;[&quot;,len(farkas),&quot;] Farkas are : &quot;, farkas, &quot; ** &quot;, pp)</span>
            <span class="n">progr</span>     <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span>
            <span class="n">index</span>     <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">progr</span><span class="p">)</span>
            <span class="n">fCapacity</span> <span class="o">=</span> <span class="p">[</span><span class="n">farkas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
            <span class="n">index</span>     <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">progr</span><span class="p">,</span><span class="n">progr</span><span class="o">+</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span>
            <span class="n">fDemand</span>   <span class="o">=</span> <span class="p">[</span><span class="n">farkas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
            <span class="n">progr</span>    <span class="o">+=</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span>
            <span class="n">nr</span>        <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="o">*</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">*</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">index</span>     <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">progr</span><span class="p">,</span> <span class="n">progr</span><span class="o">+</span><span class="n">nr</span><span class="p">)</span>
            <span class="n">fLogic</span>    <span class="o">=</span> <span class="p">[</span><span class="n">farkas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
            <span class="n">progr</span>    <span class="o">+=</span> <span class="n">nr</span>
            <span class="n">index</span>     <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">progr</span><span class="p">,</span> <span class="n">progr</span><span class="o">+</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)</span>
            <span class="n">fcumLogic</span> <span class="o">=</span> <span class="p">[</span><span class="n">farkas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>


            <span class="c1">#  feasibility cut</span>
            <span class="n">cutRhs</span>  <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">progr</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span> <span class="o">+</span> <span class="n">t</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fcumLogic</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span> <span class="o">-</span> \
                    <span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fCapacity</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                        <span class="n">coeff</span> <span class="o">+=</span> <span class="n">fLogic</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">cutVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
                    <span class="n">cutVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                    <span class="n">cutRhs</span> <span class="o">-=</span> <span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fDemand</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">cutRhs</span> <span class="o">-=</span> <span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">fCapacity</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>


        <span class="k">elif</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span> <span class="o">==</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">optimal</span><span class="p">:</span>
            <span class="n">cutType</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">zSub</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>
            <span class="c1">#  print(&quot;... ... zSUB = &quot;, zSub)</span>
            <span class="n">dCapacity</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lCapacity</span><span class="p">)</span>
            <span class="n">dDemand</span>   <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lDemand</span><span class="p">)</span>
            <span class="n">dLogic</span>    <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lLogic</span><span class="p">)</span>
            <span class="n">dcumLogic</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_dual_values</span><span class="p">(</span><span class="n">lcumLogic</span><span class="p">)</span>

            <span class="c1"># method 2: the &quot;standard&quot; benders</span>
            <span class="n">cutRhs</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">progr</span>  <span class="o">=</span> <span class="mi">0</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">dcumLogic</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span> <span class="o">-</span> \
                    <span class="n">inp</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">dCapacity</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                        <span class="n">coeff</span> <span class="o">+=</span> <span class="n">dLogic</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">cutVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
                    <span class="n">cutVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

                    <span class="n">cutRhs</span> <span class="o">-=</span> <span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">dDemand</span><span class="p">[</span><span class="n">progr</span><span class="p">]</span>

                    <span class="n">progr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">cutVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_ilo_m</span><span class="p">)</span>
            <span class="n">cutVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                <span class="n">cutRhs</span> <span class="o">-=</span> <span class="n">inp</span><span class="o">.</span><span class="n">cap</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">dCapacity</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>


        <span class="c1">#  return cut and type</span>
        <span class="n">cutLhs</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">cutVars</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">cutVals</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutLhs</span> <span class="o">=</span> <span class="n">cutLhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutRhs</span> <span class="o">=</span> <span class="n">cutRhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zSub</span>   <span class="o">=</span> <span class="n">zSub</span>

        <span class="k">return</span> <span class="n">cutType</span></div></div>

<div class="viewcode-block" id="findNext"><a class="viewcode-back" href="../clspBenders.html#clspBenders.findNext">[docs]</a><span class="k">def</span> <span class="nf">findNext</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
    <span class="c1">#  print(&quot;Item &quot;, j, &quot; from period &quot;, t)</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">maxProd</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
    <span class="c1">#  print(&quot;MAX = &quot;, maxProd)</span>
    <span class="n">dCum</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">dCum</span> <span class="o">&lt;=</span> <span class="n">maxProd</span><span class="p">:</span>
        <span class="c1">#  print(&quot;dCum vs maxProd &quot;, dCum, &quot; &quot;, maxProd, &quot; up to period &quot;,tp)</span>
        <span class="n">tp</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">tp</span> <span class="o">==</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tp</span>
        <span class="n">dCum</span> <span class="o">+=</span> <span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">tp</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tp</span></div>

<div class="viewcode-block" id="createMaster"><a class="viewcode-back" href="../clspBenders.html#clspBenders.createMaster">[docs]</a><span class="k">def</span> <span class="nf">createMaster</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create benders master problem. In reality, this is a *relaxation* of the</span>
<span class="sd">    master, to which we progressively add cuts.</span>

<span class="sd">    .. note ::</span>

<span class="sd">        The master problem provides a **lower bound** to the optimal</span>
<span class="sd">        solution.</span>

<span class="sd">    Here we try different methods to tighen the lower bound.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">z_ilo</span>
    <span class="k">global</span> <span class="n">y_ilo</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">sense</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>

    <span class="c1">#  create variables y_jt</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="n">y_ilo</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">varName</span> <span class="o">=</span> <span class="s2">&quot;y.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]],</span>
                              <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                              <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span>
                              <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">varName</span><span class="p">])</span>

    <span class="c1">#  z_ilo.append(cpx.variables.get_num())</span>
    <span class="n">z_ilo</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span>   <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
                      <span class="n">lb</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                      <span class="n">ub</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span><span class="p">],</span>
                      <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">],</span>
                      <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;zHat&quot;</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_lower_bounds</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1">#  for t in range(inp.nP-1):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1">#  hop constraint</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="n">findNext</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;... For item &quot;</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s2">&quot; we go from &quot;</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot; to &quot;</span><span class="p">,</span><span class="n">tp</span><span class="p">)</span>
                <span class="c1">#  input(&quot;...aka&quot;)</span>
                <span class="k">if</span> <span class="n">tp</span> <span class="o">&lt;</span> <span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">tp</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tp</span><span class="p">))</span>
                    <span class="n">hop_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">hop_constraint</span><span class="p">],</span>
                                               <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">],</span>
                                               <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">max_prod</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">c_constraint</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_constraint</span><span class="p">],</span>
                                   <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">],</span>
                                   <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">dcum</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span></div>





<div class="viewcode-block" id="barrierInit"><a class="viewcode-back" href="../clspBenders.html#clspBenders.barrierInit">[docs]</a><span class="k">def</span> <span class="nf">barrierInit</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>

    <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">set_sense</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">sense</span><span class="o">.</span><span class="n">maximize</span><span class="p">)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">lpmethod</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">lpmethod</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">barrier</span><span class="p">)</span>
    <span class="c1">#  cpx.parameters.solutiontype.set(2)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">barrier</span><span class="o">.</span><span class="n">crossover</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># no crossover</span>
    <span class="n">yB</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="n">yB</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">yB</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
                              <span class="n">lb</span>  <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                              <span class="n">ub</span>  <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="c1">#  print(&quot;BARRIER NO CROSSOVER SOLVED : &quot;, cpx.solution.get_objective_value())</span>
    <span class="n">ySol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="n">ySol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">yB</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
    <span class="c1">#</span>
    <span class="c1">#  print(ySol)</span>
    <span class="c1">#  input(&quot; ... barrier ... &quot;)</span>
    <span class="k">return</span> <span class="n">ySol</span></div>

<div class="viewcode-block" id="inOutCycle"><a class="viewcode-back" href="../clspBenders.html#clspBenders.inOutCycle">[docs]</a><span class="k">def</span> <span class="nf">inOutCycle</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">globalProgr</span><span class="p">):</span>

    <span class="k">global</span> <span class="n">inout</span>
    <span class="n">_lambda</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">_alpha</span>  <span class="o">=</span> <span class="mf">0.9</span>
    <span class="c1">#  progr   = cpx.linear_constraints.get_num()</span>


    <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Problem type is &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">get_problem_type</span><span class="p">()])</span>

    <span class="c1">#  now solve simple problem to get interior point</span>
    <span class="n">yt</span> <span class="o">=</span> <span class="n">barrierInit</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="nb">iter</span>           <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stopping</span>       <span class="o">=</span> <span class="mi">0</span>
    <span class="n">noImprovement</span>  <span class="o">=</span> <span class="mi">0</span>
    <span class="n">activateKelley</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bestLP</span>         <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopping</span><span class="p">:</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">zLP</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>
        <span class="n">yLP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">yLP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
        <span class="n">zHat</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">)</span>

        <span class="c1">#  print(&quot;iter &quot;, iter, &quot; with z = &quot;, zLP, &quot; vs best &quot;, bestLP)</span>
        <span class="c1">#  print(&quot;   .. current status : No Improv = &quot;, noImprovement, \</span>
                     <span class="c1">#  &quot; Kelley = &quot;, activateKelley, &quot; lambda = &quot;, _lambda)</span>
        <span class="c1">#  if zLP &gt; bestLP:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zLP</span> <span class="o">-</span> <span class="n">bestLP</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">bestLP</span> <span class="o">=</span> <span class="n">zLP</span>
            <span class="n">noImprovement</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noImprovement</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">noImprovement</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">activateKelley</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">activateKelley</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">noImprovement</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">_lambda</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stopping</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="n">yt</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">_alpha</span><span class="o">*</span><span class="n">yt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_alpha</span><span class="p">)</span><span class="o">*</span><span class="n">yLP</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
        <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
        <span class="n">ySep</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">_lambda</span><span class="o">*</span><span class="n">yLP</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_lambda</span><span class="p">)</span><span class="o">*</span><span class="n">yt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
        <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
        <span class="c1">#  ySep = [[ ySep[j][t] + 2*_EPSI for t in</span>
        <span class="c1">#  range(inp.nP)] for j in range(inp.nI)]</span>


        <span class="n">cutType</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ySep</span><span class="p">,</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>
        <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inout</span><span class="p">]</span>
            <span class="c1">#  print(&quot;checking these constraints &quot;, check)</span>

            <span class="n">slacks</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_linear_slacks</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
            <span class="c1">#  nrConstr = cpx.linear_constraints.get_num()</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slacks</span><span class="p">))</span> <span class="k">if</span> <span class="n">slacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_EPSI</span><span class="p">]</span>
            <span class="c1">#  print(&quot;removing &quot;, remove)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remove</span><span class="p">:</span>
                <span class="n">inout</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1">#  print(&quot;Removed &quot;, remove)</span>
            <span class="c1">#  print(&quot;This is inout = &quot;, inout)</span>

        <span class="k">if</span> <span class="n">cutType</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nrConstr</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;inout.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">globalProgr</span><span class="p">)</span>
            <span class="c1">#  print(&quot;adding &quot;, constrName)</span>
            <span class="n">inout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constrName</span><span class="p">)</span>
            <span class="n">globalProgr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">],</span>
                                       <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>

    <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="n">check</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inout</span><span class="p">]</span>
    <span class="n">slacks</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_linear_slacks</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
    <span class="c1">#  print(&quot;[&quot;, nrConstr,&quot;] SLACKS  == &quot;, slacks)</span>
    <span class="n">remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slacks</span><span class="p">))</span> <span class="k">if</span> <span class="n">slacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_EPSI</span><span class="p">]</span>
    <span class="c1">#  print(&quot;removing &quot;, remove)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remove</span><span class="p">:</span>
        <span class="n">inout</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="c1">#  print(&quot;OBJ AFTER REMOVING SLACKS = &quot;, cpx.solution.get_objective_value())</span>
    <span class="n">nrConstr</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ... now constr is &quot;</span><span class="p">,</span> <span class="n">nrConstr</span><span class="p">)</span>

    <span class="c1">#  zLP = cpx.solution.get_objective_value()</span>
    <span class="c1">#  yLP = []</span>
    <span class="c1">#  for j in range(inp.nI):</span>
    <span class="c1">#      yLP.append(cpx.solution.get_values(y_ilo[j]))</span>
    <span class="c1">#  zHat = cpx.solution.get_values(z_ilo)</span>
    <span class="c1">#  print(&quot;Final sol = &quot;, yLP)</span>
    <span class="c1">#  nrFixed = 0</span>
    <span class="c1">#  for j in range(inp.nI):</span>
    <span class="c1">#      for t in range(inp.nP):</span>
    <span class="c1">#          if yLP[j][t] &gt;= (1.0 - _EPSI):</span>
    <span class="c1">#              cpx.variables.set_lower_bounds(y_ilo[j][t], 1.0)</span>
    <span class="c1">#              nrFixed += 1</span>
    <span class="c1">#  print(&quot;Tot fixed to 1 is &quot;, nrFixed)</span>
    <span class="k">return</span> <span class="n">globalProgr</span></div>

<div class="viewcode-block" id="inOutCycle2"><a class="viewcode-back" href="../clspBenders.html#clspBenders.inOutCycle2">[docs]</a><span class="k">def</span> <span class="nf">inOutCycle2</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">globalProgr</span><span class="p">):</span>

    <span class="k">global</span> <span class="n">inout</span>
    <span class="n">_lambda</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">_alpha</span>  <span class="o">=</span> <span class="mf">0.9</span>
    <span class="c1">#  progr   = cpx.linear_constraints.get_num()</span>

    <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
    <span class="c1">#  print(&quot;Problem type is &quot;, cpx.problem_type[cpx.get_problem_type()])</span>

    <span class="c1">#  now solve simple problem to get interior point</span>
    <span class="n">yIn</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.9</span><span class="p">]</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
    <span class="c1">#  print(&quot;yIn = &quot;, yIn)</span>
    <span class="nb">iter</span>           <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stopping</span>       <span class="o">=</span> <span class="mi">0</span>
    <span class="n">noImprovement</span>  <span class="o">=</span> <span class="mi">0</span>
    <span class="n">activateKelley</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bestLP</span>         <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopping</span><span class="p">:</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">zLP</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zLP(&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span><span class="s2">&quot;) = &quot;</span><span class="p">,</span> <span class="n">zLP</span><span class="p">)</span>
        <span class="n">yOut</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
            <span class="n">yOut</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
        <span class="c1">#  print(&quot;yOut (LP) = &quot;, yOut)</span>
        <span class="n">zHat</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">)</span>

        <span class="c1">#  print(&quot;iter &quot;, iter, &quot; with z = &quot;, zLP, &quot; vs best &quot;, bestLP)</span>
        <span class="c1">#  print(&quot;   .. current status : No Improv = &quot;, noImprovement, \</span>
                     <span class="c1">#  &quot; Kelley = &quot;, activateKelley, &quot; lambda = &quot;, _lambda)</span>
        <span class="c1">#  if zLP &gt; bestLP:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zLP</span> <span class="o">-</span> <span class="n">bestLP</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="n">bestLP</span> <span class="o">=</span> <span class="n">zLP</span>
            <span class="n">noImprovement</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noImprovement</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">noImprovement</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">activateKelley</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">activateKelley</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">noImprovement</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">_lambda</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stopping</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="n">ySep</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">_lambda</span><span class="o">*</span><span class="n">yOut</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_lambda</span><span class="p">)</span><span class="o">*</span><span class="n">yIn</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
        <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
        <span class="n">ySep</span> <span class="o">=</span> <span class="p">[[</span> <span class="n">ySep</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">_EPSI</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
        <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>


        <span class="n">cutType</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ySep</span><span class="p">,</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>
        <span class="n">flatten</span> <span class="o">=</span>  <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">ySep</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
        <span class="n">lhsSum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">flatten</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)])</span>
        <span class="c1">#  print(&quot;LhsSum = &quot;, lhsSum , &quot; vs &quot;, worker.cutRhs)</span>
        <span class="c1">#  print(lhsSum &lt;= worker.cutRhs)</span>
        <span class="n">violated</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhsSum</span> <span class="o">-</span> <span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span>
        <span class="c1">#  print(&quot; violated ? &quot;, violated)</span>

        <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inout</span><span class="p">]</span>
            <span class="c1">#  print(&quot;checking these constraints &quot;, check)</span>

            <span class="n">slacks</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_linear_slacks</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
            <span class="c1">#  nrConstr = cpx.linear_constraints.get_num()</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slacks</span><span class="p">))</span> <span class="k">if</span> <span class="n">slacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_EPSI</span><span class="p">]</span>
            <span class="c1">#  print(&quot;removing &quot;, remove)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remove</span><span class="p">:</span>
                <span class="n">inout</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1">#  print(&quot;Removed &quot;, remove)</span>
            <span class="c1">#  print(&quot;This is inout = &quot;, inout)</span>

        <span class="k">if</span> <span class="n">violated</span><span class="p">:</span>
            <span class="c1">#  progr = cpx.linear_constraints.get_num()</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;inout.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">globalProgr</span><span class="p">)</span>
            <span class="c1">#  print(&quot;adding &quot;, constrName)</span>
            <span class="n">inout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constrName</span><span class="p">)</span>
            <span class="n">globalProgr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">],</span>
                                       <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yIn</span> <span class="o">=</span> <span class="n">ySep</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;... not violated ... moving &#39;in&#39; point&quot;</span><span class="p">)</span>

    <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="n">check</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inout</span><span class="p">]</span>
    <span class="n">slacks</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_linear_slacks</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
    <span class="c1">#  print(&quot;[&quot;, nrConstr,&quot;] SLACKS  == &quot;, slacks)</span>
    <span class="n">remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slacks</span><span class="p">))</span> <span class="k">if</span> <span class="n">slacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_EPSI</span><span class="p">]</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remove</span><span class="p">:</span>
        <span class="n">inout</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="c1">#  print(&quot;OBJ AFTER REMOVING SLACKS = &quot;, cpx.solution.get_objective_value())</span>
    <span class="n">nrConstr</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ... now constr is &quot;</span><span class="p">,</span> <span class="n">nrConstr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">globalProgr</span></div>

<div class="viewcode-block" id="fixingToZero"><a class="viewcode-back" href="../clspBenders.html#clspBenders.fixingToZero">[docs]</a><span class="k">def</span> <span class="nf">fixingToZero</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">bestLB</span><span class="p">,</span> <span class="n">bestUB</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">yFixed</span><span class="p">):</span>
    <span class="n">cpxClone</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
    <span class="n">cpxClone</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpxClone</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
    <span class="n">cpxClone</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">cpxClone</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_reduced_costs</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cpxClone</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">_EPSI</span> <span class="ow">and</span> \
                <span class="n">yFixed</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bestLB</span> <span class="o">+</span> <span class="n">rc</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">bestUB</span><span class="p">:</span>
                <span class="n">yFixed</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; +** ** ** ** fixing to zero &quot;</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">])</span>
                <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_upper_bounds</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span></div>

<div class="viewcode-block" id="addCorridor"><a class="viewcode-back" href="../clspBenders.html#clspBenders.addCorridor">[docs]</a><span class="k">def</span> <span class="nf">addCorridor</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">cWidth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. func:addCorridor()</span>

<span class="sd">    This function implements the corridor method for Benders&#39; decomposition.</span>
<span class="sd">    The idea can be described as follows: Every time a new incumbent solution</span>
<span class="sd">    is found by the subproblem (i.e., a feasible solution which improves the</span>
<span class="sd">    upper bound), a new best solution is obtained. Let us indicate with :math:`y^I` </span>
<span class="sd">    such solution. After adding the corresponding optimality cut to the master,</span>
<span class="sd">    we also impose the following corridor constraint:</span>

<span class="sd">    .. math ::</span>
<span class="sd">        :nowrap:</span>
<span class="sd">        </span>
<span class="sd">        \\begin{equation}</span>
<span class="sd">        \sum_{t=1}^T y^I_{jt}\left(1-y_{jt}\\right) + \left(1-y^I_{jt}\\right)y_{jt} \leq</span>
<span class="sd">        \gamma nT</span>
<span class="sd">        \end{equation}</span>

<span class="sd">    which ensure that no more than :math:`\gamma` percent of the setup</span>
<span class="sd">    variables will change value. This approach imposes a maximum hamming</span>
<span class="sd">    distance with respect to the incumbent solution, thus</span>
<span class="sd">    restricting the solution space of the master problem. This allows to speed up</span>
<span class="sd">    the convergence of Benders&#39; algorithm. </span>
<span class="sd"> </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span>
    <span class="n">rhsVal</span> <span class="o">=</span> <span class="n">cWidth</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
    <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)])</span>
    <span class="n">corridor_constr</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">index</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">corridor_constr</span><span class="p">],</span>
                               <span class="n">senses</span>   <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
                               <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">rhsVal</span><span class="p">],</span>
                               <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;corridor&quot;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;... [&quot;</span><span class="p">,</span><span class="n">cWidth</span><span class="p">,</span><span class="s2">&quot;] After adding corridor constr : &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span></div>

<div class="viewcode-block" id="setCpxParameters"><a class="viewcode-back" href="../clspBenders.html#clspBenders.setCpxParameters">[docs]</a><span class="k">def</span> <span class="nf">setCpxParameters</span><span class="p">(</span><span class="n">cpx</span><span class="p">):</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">off</span><span class="p">)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">threads</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mip</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">search</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mip</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">search</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">traditional</span><span class="p">)</span></div>

<div class="viewcode-block" id="getSolution"><a class="viewcode-back" href="../clspBenders.html#clspBenders.getSolution">[docs]</a><span class="k">def</span> <span class="nf">getSolution</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">):</span>
    <span class="n">ySol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">zHat</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">z_ilo</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="n">ySol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">ySol</span></div>

<div class="viewcode-block" id="getUB"><a class="viewcode-back" href="../clspBenders.html#clspBenders.getUB">[docs]</a><span class="k">def</span> <span class="nf">getUB</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">zSub</span><span class="p">,</span> <span class="n">ySol</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">zSub</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">z</span> <span class="o">+=</span> <span class="n">inp</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">ySol</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="benderAlgorithm"><a class="viewcode-back" href="../clspBenders.html#clspBenders.benderAlgorithm">[docs]</a><span class="k">def</span> <span class="nf">benderAlgorithm</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">fixToZero</span><span class="p">,</span> <span class="n">fixToOne</span><span class="p">,</span> <span class="n">cPercent</span><span class="p">,</span> <span class="n">cZero</span><span class="p">,</span> <span class="n">cOne</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. func:benderAlgorithm()</span>

<span class="sd">    This function implements Benders&#39; scheme without the use of callbacks. We</span>
<span class="sd">    thus define a cycle that iteratively solves the master and the subproblems,</span>
<span class="sd">    until a termination criterion is reached.</span>
<span class="sd">    </span>
<span class="sd">    The current implementation is heuristic in nature, since fixing schemes as</span>
<span class="sd">    well as a corridor are used. Therefore, there is no guarantee that the</span>
<span class="sd">    solution returned by this algorithm is optimal. To get an exact approach,</span>
<span class="sd">    deactivate the fixing schemes (to zero and to one) and the corridor scheme.</span>

<span class="sd">    We make use of an in-out cycle, in a fashion similar to what has been done</span>
<span class="sd">    by Fischetti for the uncapacitated facility location problem (see their MS</span>
<span class="sd">    paper.) Probably, this part could be improved, to make it faster. However,</span>
<span class="sd">    it seems important to reach a good lower bound quickly. If the in-out cycle</span>
<span class="sd">    is not used, the lower bound is much worse and the convergence is extremely</span>
<span class="sd">    slow.</span>

<span class="sd">    Another feature of the Benders&#39; implementation is connected with the use of</span>
<span class="sd">    a pool of solutions. Before calling Benders&#39; algorithm, we heuristically</span>
<span class="sd">    solve the original CLSP with a maximum number of solutions to be reached.</span>
<span class="sd">    During this call to cplex, we collect a *pool* of solutions, which can be</span>
<span class="sd">    used to tighten the master. The idea is that we then pass these solutions</span>
<span class="sd">    to the separation scheme. Alternative approaches have been explored, e.g.,</span>
<span class="sd">    producing feasible solutions using a Cross Entropy scheme and, then, apply</span>
<span class="sd">    the separation mechanism to each of these solutions. To get the pool of</span>
<span class="sd">    solution, it suffices to call :meth:`MIP.solve()` with the flag ``withPool=1``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">globalProgr</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#  these are parameters for the corridor and the fixing schemes</span>
    <span class="n">nWidth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cPercent</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nZero</span>  <span class="o">=</span> <span class="n">cZero</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fixToZero</span><span class="p">)</span>
    <span class="n">nOne</span>   <span class="o">=</span> <span class="n">cOne</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fixToOne</span><span class="p">)</span>

    <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
    <span class="c1">#  cpx.set_results_stream(None)</span>
    <span class="c1">#  cpx.set_log_stream(None)</span>
    <span class="n">createMaster</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">)</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="n">WorkerLPReformulation</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">setCpxParameters</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>

    <span class="n">globalProgr</span> <span class="o">=</span> <span class="n">inOutCycle2</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">globalProgr</span><span class="p">)</span>
    <span class="c1">#  cpx.write(&quot;inout-12-15.lp&quot;)</span>
    <span class="c1">#  cpx.read(&quot;inout-12-15.lp&quot;)</span>
    <span class="c1">#  cpx.read(&quot;inout-6-15.lp&quot;)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">MILP</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_types</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">binary</span><span class="p">)</span>

    <span class="c1">#  add some fixing scheme here</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FIX TO ZERO HERE = &quot;</span><span class="p">,</span> <span class="n">fixToZero</span><span class="p">)</span>
    <span class="n">zero_cut</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">fixToZero</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fixToZero</span><span class="p">))</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">zero_cut</span><span class="p">],</span>
                               <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                               <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">nZero</span><span class="p">])</span>
<span class="c1">#</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FIX TO ONE HERE = &quot;</span><span class="p">,</span> <span class="n">fixToOne</span><span class="p">)</span>
    <span class="n">one_cut</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">fixToOne</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fixToOne</span><span class="p">))</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">one_cut</span><span class="p">],</span>
                               <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">],</span>
                               <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">nOne</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Before adding cut to master : &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPool</span><span class="p">):</span>
    <span class="c1">#  for i in range(0):</span>
        <span class="n">cutType</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">yPool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cutType</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;heur.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">],</span>
                                       <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After adding Pool cut to master : &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>

    <span class="c1">#  #  add corridor constraint</span>
    <span class="n">addCorridor</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">yPool</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">nWidth</span><span class="p">)</span>

    <span class="c1">#  initialize data structure</span>
    <span class="n">yFixed</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
    <span class="n">ySol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="n">ySol</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">zHat</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">nIter</span>        <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stopping</span>     <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nrCuts</span>       <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bestLB</span>       <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">maxTolerance</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">bestUB</span>       <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span>
    <span class="n">gap</span>          <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">infinity</span>
    <span class="c1"># Benders&#39; main cycle</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopping</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nIter</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">globalProgr</span> <span class="o">=</span> <span class="n">inOutCycle</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">globalProgr</span><span class="p">)</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">MILP</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
                    <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_types</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">binary</span><span class="p">)</span>

        <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">bestLB</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bestUB</span> <span class="o">-</span> <span class="n">bestLB</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">maxTolerance</span><span class="p">:</span>
            <span class="n">stopping</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="c1">#  get master solution</span>
        <span class="n">zHat</span><span class="p">,</span> <span class="n">ySol</span> <span class="o">=</span> <span class="n">getSolution</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>

        <span class="c1">#  solve subproblem and add separation cut</span>
        <span class="n">cutType</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ySol</span><span class="p">,</span> <span class="n">zHat</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cutType</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cutName</span> <span class="o">=</span> <span class="s2">&quot;cut.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nrCuts</span><span class="p">)</span>
            <span class="n">nrCuts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="p">],</span>
                                       <span class="n">senses</span>   <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">],</span>
                                       <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">],</span>
                                       <span class="n">names</span>    <span class="o">=</span> <span class="p">[</span><span class="n">cutName</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cutType</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># optimality cut</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">getUB</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">worker</span><span class="o">.</span><span class="n">zSub</span><span class="p">,</span> <span class="n">ySol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ub</span> <span class="o">&lt;</span> <span class="n">bestUB</span> <span class="ow">or</span> <span class="p">((</span><span class="n">nIter</span> <span class="o">%</span> <span class="mi">5</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">gap</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ub</span> <span class="o">&lt;</span> <span class="n">bestUB</span><span class="p">:</span>
                    <span class="n">bestUB</span> <span class="o">=</span> <span class="n">ub</span>
                    <span class="c1">#  add corridor constraint</span>
                    <span class="n">addCorridor</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">yPool</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">nWidth</span><span class="p">)</span>

                <span class="n">fixingToZero</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">bestLB</span><span class="p">,</span> <span class="n">bestUB</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">yFixed</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">bestUB</span> <span class="o">-</span> <span class="n">bestLB</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">maxTolerance</span><span class="p">:</span>
                <span class="n">stopping</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">continue</span>

        <span class="n">nIter</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">bestLB</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">gap</span> <span class="o">=</span> <span class="p">(</span><span class="n">bestUB</span><span class="o">-</span><span class="n">bestLB</span><span class="p">)</span><span class="o">/</span><span class="n">bestLB</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iter </span><span class="si">{0:5d}</span><span class="s2"> :: GAP = </span><span class="si">{1:8.3f}</span><span class="s2"> ... LB = </span><span class="si">{2:8.3f}</span><span class="s2"> vs UB =</span><span class="se">\</span>
<span class="s2">        </span><span class="si">{3:8.3f}</span><span class="s2">. ### Added </span><span class="si">{4:5d}</span><span class="s2"> cuts.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nIter</span><span class="p">,</span> <span class="n">gap</span><span class="p">,</span> <span class="n">bestLB</span><span class="p">,</span> <span class="n">bestUB</span><span class="p">,</span> \
        <span class="n">nrCuts</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final Result ====== &quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ** LB = &quot;</span><span class="p">,</span> <span class="n">bestLB</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ** UB = &quot;</span><span class="p">,</span> <span class="n">bestUB</span><span class="p">)</span></div>



<div class="viewcode-block" id="main"><a class="viewcode-back" href="../clspBenders.html#clspBenders.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Entry point.</span>

<span class="sd">    We first parse the command line, then reading the instance from a disk</span>
<span class="sd">    file.</span>

<span class="sd">    The algorithm to be used is selected via command line using flag -a. See</span>
<span class="sd">    :func:`parseCommandLine()` for more details on flags and options for this</span>
<span class="sd">    code.</span>

<span class="sd">    With respect to the type of algorithms that can be used, we have:</span>

<span class="sd">        1.  Benders Decomposition</span>
<span class="sd">        2.  Lagrangean Relaxation</span>
<span class="sd">        3.  Dantzig-Wolfe</span>
<span class="sd">        4.  Cplex MIP solver</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parseCommandLine</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">inputfile</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">algo</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mip</span>       <span class="o">=</span> <span class="n">MIPReformulation</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">fixToZero</span> <span class="o">=</span> <span class="n">mip</span><span class="o">.</span><span class="n">solveLPZero</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">fixToOne</span>  <span class="o">=</span> <span class="n">mip</span><span class="o">.</span><span class="n">solveLPOne</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">zHeur</span>     <span class="o">=</span> <span class="n">mip</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span><span class="n">nSol</span>    <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">display</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">withPool</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zHeur = &quot;</span><span class="p">,</span> <span class="n">zHeur</span><span class="p">)</span>
        <span class="n">benderAlgorithm</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">fixToZero</span><span class="p">,</span> <span class="n">fixToOne</span><span class="p">,</span> <span class="n">cPercent</span><span class="p">,</span> <span class="n">cZero</span><span class="p">,</span> <span class="n">cOne</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">101</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">algo</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">mip</span>       <span class="o">=</span> <span class="n">MIPReformulation</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">fixToZero</span> <span class="o">=</span> <span class="n">mip</span><span class="o">.</span><span class="n">solveLPZero</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">fixToOne</span>  <span class="o">=</span> <span class="n">mip</span><span class="o">.</span><span class="n">solveLPOne</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">lagrange</span> <span class="o">=</span> <span class="n">Lagrange</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="mi">99999999</span><span class="p">)</span>
        <span class="n">lagrange</span><span class="o">.</span><span class="n">lagrangeanPhase</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">mip</span><span class="p">,</span> <span class="n">fixToZero</span><span class="p">,</span> <span class="n">fixToOne</span><span class="p">,</span> <span class="n">cPercent</span><span class="p">,</span> <span class="n">cZero</span><span class="p">,</span>
        <span class="n">cOne</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">102</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">algo</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">DantzigWolfe</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">dw</span><span class="o">.</span><span class="n">dw_cycle</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">103</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">algo</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c1">#  Cplex MIP solver</span>
        <span class="n">mip</span>       <span class="o">=</span> <span class="n">MIPReformulation</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">mip</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">withPrinting</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">104</span><span class="p">)</span>


    <span class="c1">#  ======================================================================</span>
    <span class="c1">#  All this stuff below is used to define cplex callback. This was the first</span>
    <span class="c1">#  version of Benders implementation. It is no longer needed.</span>
    <span class="c1">#  ======================================================================</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
    <span class="n">cpxClone</span> <span class="o">=</span> <span class="n">cplex</span><span class="o">.</span><span class="n">Cplex</span><span class="p">()</span>
    <span class="c1"># create master and worker (subproblem)</span>
    <span class="n">createMaster</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpx</span><span class="p">)</span>
    <span class="n">createMaster</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">cpxClone</span><span class="p">)</span>
    <span class="n">cpxClone</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">LP</span><span class="p">)</span>
    <span class="c1">#  worker = WorkerLP(inp)</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="n">WorkerLPReformulation</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

    <span class="c1"># Set up cplex parameters to use the cut callback for separating</span>
    <span class="c1"># Benders&#39; cuts</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">presolve</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">off</span><span class="p">)</span>
    <span class="c1"># Set the maximum number of threads to 1.</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">threads</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Turn on traditional search for use with control callbacks</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mip</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">search</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mip</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">search</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">traditional</span><span class="p">)</span>

    <span class="c1">#  inOutCycle(cpx, worker, y_ilo, z_ilo, inp)</span>
    <span class="c1">#  cpx.write(&quot;inout-6-15.lp&quot;)</span>

    <span class="n">cpx</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;inout-6-15.lp&quot;</span><span class="p">)</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">set_problem_type</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="o">.</span><span class="n">MILP</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Type here = &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">problem_type</span><span class="p">[</span><span class="n">cpx</span><span class="o">.</span><span class="n">get_problem_type</span><span class="p">()])</span>

    <span class="c1">#  binary variables must be re-specified</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">):</span>
            <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">set_types</span><span class="p">(</span><span class="n">y_ilo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="p">],</span> <span class="n">cpx</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">binary</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Before adding cut to master : &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
    <span class="n">cutType</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">yRef</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y_ilo</span><span class="p">,</span> <span class="n">z_ilo</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cutType</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">constrName</span> <span class="o">=</span> <span class="s2">&quot;heur.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutLhs</span><span class="p">],</span>
                                   <span class="n">senses</span>   <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
                                   <span class="n">rhs</span>      <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">cutRhs</span><span class="p">],</span>
                                   <span class="n">inames</span>    <span class="o">=</span> <span class="p">[</span><span class="n">constrName</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cut added to master : &quot;</span><span class="p">,</span> <span class="n">cpx</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">())</span>
    <span class="c1">#  solveCall = cpx.register_callback(SolveNodeCallback)</span>

    <span class="c1"># register LAZY callback</span>
    <span class="n">lazyBenders</span>        <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">BendersLazyConsCallback</span><span class="p">)</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">cpx</span>    <span class="o">=</span> <span class="n">cpx</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">inp</span>    <span class="o">=</span> <span class="n">inp</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">z_ilo</span>  <span class="o">=</span> <span class="n">z_ilo</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">y_ilo</span>  <span class="o">=</span> <span class="n">y_ilo</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">yFixed</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nP</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">nI</span><span class="p">)]</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">worker</span> <span class="o">=</span> <span class="n">worker</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">rc</span>     <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lazyBenders</span><span class="o">.</span><span class="n">nIter</span>  <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">userCuts</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
        <span class="c1"># register USER callback</span>
        <span class="n">userBenders</span>        <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">BendersUserCutCallback</span><span class="p">)</span>
        <span class="n">userBenders</span><span class="o">.</span><span class="n">inp</span>    <span class="o">=</span> <span class="n">inp</span>
        <span class="n">userBenders</span><span class="o">.</span><span class="n">z_ilo</span>  <span class="o">=</span> <span class="n">z_ilo</span>
        <span class="n">userBenders</span><span class="o">.</span><span class="n">y_ilo</span>  <span class="o">=</span> <span class="n">y_ilo</span>
        <span class="n">userBenders</span><span class="o">.</span><span class="n">worker</span> <span class="o">=</span> <span class="n">worker</span>

    <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Solve the model</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="n">solution</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">solution</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solution status: &quot;</span><span class="p">,</span> <span class="n">solution</span><span class="o">.</span><span class="n">status</span><span class="p">[</span><span class="n">solution</span><span class="o">.</span><span class="n">get_status</span><span class="p">()])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Objective value: &quot;</span><span class="p">,</span> <span class="n">solution</span><span class="o">.</span><span class="n">get_objective_value</span><span class="p">())</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thus time is &quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MIMPLS Benders 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Marco Caserta.
      Last updated on Jun 01, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>